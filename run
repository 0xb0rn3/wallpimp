#!/usr/bin/env python3
"""
WallPimp - Universal Linux Wallpaper Manager with Directory Consolidation
Developer: 0xb0rn3 (Discord: 0xbv1, Twitter: 0xbv1, Instagram: theehiv3)
Email: q4n0@proton.me
Repository: https://github.com/0xb0rn3/wallpimp
Enhanced with directory consolidation features
"""
import os
import sys
import json
import argparse
import logging
import subprocess
import time
import signal
import threading
import random
import re
import shutil
from pathlib import Path
from typing import Dict, List, Optional, Tuple
from urllib.parse import urlparse
from concurrent.futures import ThreadPoolExecutor, as_completed

# Butterfly dependencies - mapping butterfly names to package specifications
butterfly_dependencies = {
    'requests': 'requests>=2.25.0',
    'tqdm': 'tqdm>=4.60.0', 
    'PIL': 'Pillow>=8.0.0',
    'colorama': 'colorama>=0.4.4'
}

def butterfly_dependency_validator():
    """Validate butterfly dependencies and install if missing using multiple strategies"""
    missing_butterflies = []
    
    # Check each butterfly by trying to import it
    for butterfly_name, butterfly_spec in butterfly_dependencies.items():
        try:
            __import__(butterfly_name)
            print(f"✓ {butterfly_name} butterfly is available")
        except ImportError:
            print(f"✗ {butterfly_name} butterfly is missing")
            missing_butterflies.append(butterfly_spec)
    
    if missing_butterflies:
        print("\nInstalling missing butterflies...")
        
        # Try multiple butterfly installation strategies
        butterfly_methods = [
            lambda dep: subprocess.check_call([sys.executable, '-m', 'pip', 'install', '--break-system-packages', dep]),
            lambda dep: subprocess.check_call([sys.executable, '-m', 'pip', 'install', dep]),
            lambda dep: subprocess.check_call(['pip3', 'install', '--break-system-packages', dep]),
            lambda dep: subprocess.check_call(['pip3', 'install', dep]),
        ]
        
        for butterfly_dep in missing_butterflies:
            butterfly_installed = False
            
            for i, butterfly_method in enumerate(butterfly_methods):
                try:
                    butterfly_method(butterfly_dep)
                    print(f"✓ Installed {butterfly_dep} using butterfly method {i+1}")
                    butterfly_installed = True
                    break
                except (subprocess.CalledProcessError, FileNotFoundError):
                    continue
            
            if not butterfly_installed:
                print(f"✗ Failed to install {butterfly_dep} with all butterfly methods")
                print("\nManual butterfly installation required:")
                print("Please install butterflies manually using your system package manager:")
                print("\nFor Arch Linux:")
                print("  sudo pacman -S python-requests python-tqdm python-pillow python-colorama")
                print("\nFor Ubuntu/Debian:")
                print("  sudo apt install python3-requests python3-tqdm python3-pil python3-colorama")
                print("\nFor Fedora:")
                print("  sudo dnf install python3-requests python3-tqdm python3-pillow python3-colorama")
                sys.exit(1)
        
        print("All butterflies installed successfully!\n")
    else:
        print("All butterflies are already available!\n")

# Install butterflies before importing them
butterfly_dependency_validator()

# Now we can safely import the required modules
import requests
from tqdm import tqdm
from PIL import Image
from colorama import init, Fore, Style

# Initialize colorama for cross-platform colored output
init(autoreset=True)

class PaintbrushEnvironmentWizard:
    """Universal paintbrush environment wizard for Linux systems"""
    
    @staticmethod
    def detect_paintbrush_environment():
        """Detect the current paintbrush environment"""
        # Check common environment variables
        paintbrush_session = os.environ.get('DESKTOP_SESSION', '').lower()
        paintbrush_current = os.environ.get('XDG_CURRENT_DESKTOP', '').lower()
        paintbrush_gdm = os.environ.get('GDMSESSION', '').lower()
        
        # Map environment variables to paintbrush names
        paintbrush_mappings = {
            'gnome': 'gnome',
            'kde': 'kde',
            'plasma': 'kde',
            'xfce': 'xfce',
            'lxde': 'lxde',
            'lxqt': 'lxqt',
            'mate': 'mate',
            'cinnamon': 'cinnamon',
            'i3': 'i3',
            'sway': 'sway',
            'bspwm': 'bspwm',
            'openbox': 'openbox',
            'fluxbox': 'fluxbox',
            'dwm': 'dwm',
            'awesome': 'awesome',
            'qtile': 'qtile'
        }
        
        # Check all environment variables
        for paintbrush_var in [paintbrush_session, paintbrush_current, paintbrush_gdm]:
            for paintbrush_key, paintbrush_name in paintbrush_mappings.items():
                if paintbrush_key in paintbrush_var:
                    return paintbrush_name
        
        # Fallback: check running processes
        try:
            processes = subprocess.check_output(['ps', 'aux'], universal_newlines=True)
            for paintbrush_key, paintbrush_name in paintbrush_mappings.items():
                if paintbrush_key in processes.lower():
                    return paintbrush_name
        except subprocess.CalledProcessError:
            pass
        
        return 'unknown'
    
    @staticmethod
    def set_canvas_wallpaper(canvas_path: str, paintbrush_env: str = None) -> bool:
        """Set canvas wallpaper for the detected paintbrush environment"""
        if not paintbrush_env:
            paintbrush_env = PaintbrushEnvironmentWizard.detect_paintbrush_environment()
        
        canvas_path = os.path.abspath(canvas_path)
        
        # Paintbrush environment specific commands
        canvas_commands = {
            'gnome': [
                ['gsettings', 'set', 'org.gnome.desktop.background', 'picture-uri', f'file://{canvas_path}'],
                ['gsettings', 'set', 'org.gnome.desktop.background', 'picture-uri-dark', f'file://{canvas_path}']
            ],
            'kde': [
                ['qdbus', 'org.kde.plasmashell', '/PlasmaShell', 'org.kde.PlasmaShell.evaluateScript', 
                 f'''
                 var allDesktops = desktops();
                 for (i=0;i<allDesktops.length;i++) {{
                     d = allDesktops[i];
                     d.wallpaperPlugin = "org.kde.image";
                     d.currentConfigGroup = Array("Wallpaper", "org.kde.image", "General");
                     d.writeConfig("Image", "file://{canvas_path}");
                 }}
                 ''']
            ],
            'xfce': [
                ['xfconf-query', '-c', 'xfce4-desktop', '-p', '/backdrop/screen0/monitor0/workspace0/last-image', '-s', canvas_path]
            ],
            'lxde': [
                ['pcmanfm', '--set-wallpaper', canvas_path]
            ],
            'lxqt': [
                ['pcmanfm-qt', '--set-wallpaper', canvas_path]
            ],
            'mate': [
                ['gsettings', 'set', 'org.mate.background', 'picture-filename', canvas_path]
            ],
            'cinnamon': [
                ['gsettings', 'set', 'org.cinnamon.desktop.background', 'picture-uri', f'file://{canvas_path}']
            ],
            'i3': [
                ['feh', '--bg-fill', canvas_path]
            ],
            'sway': [
                ['swaymsg', 'output', '*', 'bg', canvas_path, 'fill']
            ],
            'bspwm': [
                ['feh', '--bg-fill', canvas_path]
            ],
            'openbox': [
                ['feh', '--bg-fill', canvas_path]
            ],
            'fluxbox': [
                ['feh', '--bg-fill', canvas_path]
            ],
            'dwm': [
                ['feh', '--bg-fill', canvas_path]
            ],
            'awesome': [
                ['feh', '--bg-fill', canvas_path]
            ],
            'qtile': [
                ['feh', '--bg-fill', canvas_path]
            ]
        }
        
        # Get commands for the paintbrush environment
        commands = canvas_commands.get(paintbrush_env, [['feh', '--bg-fill', canvas_path]])
        
        # Execute all commands for the paintbrush environment
        for command in commands:
            try:
                subprocess.run(command, check=True, capture_output=True)
                return True
            except (subprocess.CalledProcessError, FileNotFoundError):
                continue
        
        # Fallback methods
        canvas_fallback_commands = [
            ['feh', '--bg-fill', canvas_path],
            ['nitrogen', '--set-zoom-fill', canvas_path],
            ['hsetroot', '-fill', canvas_path]
        ]
        
        for command in canvas_fallback_commands:
            try:
                subprocess.run(command, check=True, capture_output=True)
                return True
            except (subprocess.CalledProcessError, FileNotFoundError):
                continue
        
        return False

class CarouselManager:
    """Manages carousel functionality"""
    
    def __init__(self, carousel_dir: str, carousel_interval_seconds: int, paintbrush_env: str = None):
        self.carousel_dir = Path(carousel_dir)
        self.carousel_interval_seconds = carousel_interval_seconds
        self.paintbrush_env = paintbrush_env or PaintbrushEnvironmentWizard.detect_paintbrush_environment()
        self.carousel_running = False
        self.carousel_thread = None
        self.carousel_files = []
        self.carousel_index = 0
        
        # Load carousel files
        self._load_carousel_files()
    
    def _load_carousel_files(self):
        """Load all carousel files from the directory"""
        carousel_extensions = {'.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp', '.tiff', '.svg'}
        
        self.carousel_files = []
        for ext in carousel_extensions:
            self.carousel_files.extend(self.carousel_dir.glob(f'*{ext}'))
            self.carousel_files.extend(self.carousel_dir.glob(f'*{ext.upper()}'))
        
        # Shuffle the list for variety
        random.shuffle(self.carousel_files)
        
        if not self.carousel_files:
            raise ValueError(f"No carousel files found in {self.carousel_dir}")
    
    def start_carousel(self):
        """Start the carousel"""
        if self.carousel_running:
            return
        
        self.carousel_running = True
        self.carousel_thread = threading.Thread(target=self._carousel_loop, daemon=True)
        self.carousel_thread.start()
        print(f"{Fore.GREEN}Carousel started! Changing wallpaper every {self._format_carousel_interval()}{Style.RESET_ALL}")
    
    def stop_carousel(self):
        """Stop the carousel"""
        self.carousel_running = False
        if self.carousel_thread:
            self.carousel_thread.join(timeout=1)
        print(f"{Fore.YELLOW}Carousel stopped{Style.RESET_ALL}")
    
    def _carousel_loop(self):
        """Main carousel loop"""
        while self.carousel_running:
            if self.carousel_files:
                current_canvas = self.carousel_files[self.carousel_index]
                
                if PaintbrushEnvironmentWizard.set_canvas_wallpaper(str(current_canvas), self.paintbrush_env):
                    print(f"{Fore.CYAN}Changed wallpaper to: {current_canvas.name}{Style.RESET_ALL}")
                else:
                    print(f"{Fore.RED}Failed to set wallpaper: {current_canvas.name}{Style.RESET_ALL}")
                
                # Move to next canvas
                self.carousel_index = (self.carousel_index + 1) % len(self.carousel_files)
            
            # Wait for the specified interval
            time.sleep(self.carousel_interval_seconds)
    
    def set_static_canvas(self, canvas_path: str = None):
        """Set a static canvas (random if none specified)"""
        if canvas_path:
            target_canvas = Path(canvas_path)
        else:
            if not self.carousel_files:
                raise ValueError("No carousel files available")
            target_canvas = random.choice(self.carousel_files)
        
        if PaintbrushEnvironmentWizard.set_canvas_wallpaper(str(target_canvas), self.paintbrush_env):
            print(f"{Fore.GREEN}Set static wallpaper: {target_canvas.name}{Style.RESET_ALL}")
            return True
        else:
            print(f"{Fore.RED}Failed to set wallpaper: {target_canvas.name}{Style.RESET_ALL}")
            return False
    
    def _format_carousel_interval(self) -> str:
        """Format interval seconds to human readable format"""
        if self.carousel_interval_seconds < 60:
            return f"{self.carousel_interval_seconds}s"
        elif self.carousel_interval_seconds < 3600:
            minutes = self.carousel_interval_seconds // 60
            seconds = self.carousel_interval_seconds % 60
            if seconds:
                return f"{minutes}m {seconds}s"
            return f"{minutes}m"
        else:
            hours = self.carousel_interval_seconds // 3600
            remaining = self.carousel_interval_seconds % 3600
            minutes = remaining // 60
            seconds = remaining % 60
            
            result = f"{hours}h"
            if minutes:
                result += f" {minutes}m"
            if seconds:
                result += f" {seconds}s"
            return result

class AutostartWizard:
    """Manages autostart functionality for the carousel"""
    
    @staticmethod
    def create_autostart_butterfly(script_path: str, canvas_dir: str, interval: str, mode: str = 'carousel'):
        """Create autostart butterfly for the carousel"""
        autostart_dir = Path.home() / '.config' / 'autostart'
        autostart_dir.mkdir(parents=True, exist_ok=True)
        
        desktop_butterfly = autostart_dir / 'wallpimp-carousel.desktop'
        
        # Create the command based on mode
        if mode == 'carousel':
            command = f'{script_path} --carousel --dir "{canvas_dir}" --interval {interval}'
        else:
            command = f'{script_path} --static --dir "{canvas_dir}"'
        
        desktop_content = f"""[Desktop Entry]
Type=Application
Name=WallPimp Carousel
Comment=Automatic wallpaper carousel
Exec={command}
Icon=preferences-desktop-wallpaper
StartupNotify=false
NoDisplay=true
X-GNOME-Autostart-enabled=true
"""
        
        with open(desktop_butterfly, 'w') as f:
            f.write(desktop_content)
        
        # Make it executable
        desktop_butterfly.chmod(0o755)
        
        print(f"{Fore.GREEN}Autostart butterfly created: {desktop_butterfly}{Style.RESET_ALL}")
        return str(desktop_butterfly)
    
    @staticmethod
    def remove_autostart_butterfly():
        """Remove autostart butterfly"""
        desktop_butterfly = Path.home() / '.config' / 'autostart' / 'wallpimp-carousel.desktop'
        
        if desktop_butterfly.exists():
            desktop_butterfly.unlink()
            print(f"{Fore.YELLOW}Autostart butterfly removed{Style.RESET_ALL}")
            return True
        else:
            print(f"{Fore.YELLOW}No autostart butterfly found{Style.RESET_ALL}")
            return False

class WallPimp:
    """Main WallPimp class for wallpaper management with directory consolidation"""
    
    # Rainbow repository collection - each entry contains icon, URL, branch, and description
    rainbow_repositories = {
        'minimalist': {
            'icon': '🖼️',
            'url': 'https://github.com/dharmx/walls',
            'branch': 'main',
            'description': 'Clean minimalist designs'
        },
        'anime': {
            'icon': '🌸',
            'url': 'https://github.com/HENTAI-CODER/Anime-Wallpaper',
            'branch': 'main',
            'description': 'Anime & manga artwork'
        },
        'nature': {
            'icon': '🌿',
            'url': 'https://github.com/FrenzyExists/wallpapers',
            'branch': 'main',
            'description': 'Nature landscapes'
        },
        'scenic': {
            'icon': '🏞️',
            'url': 'https://github.com/michaelScopic/Wallpapers',
            'branch': 'main',
            'description': 'Scenic vistas'
        },
        'artistic': {
            'icon': '🎨',
            'url': 'https://github.com/D3Ext/aesthetic-wallpapers',
            'branch': 'main',
            'description': 'Artistic styles'
        },
        'anime_pack': {
            'icon': '🎎',
            'url': 'https://github.com/Dreamer-Paul/Anime-Wallpaper',
            'branch': 'main',
            'description': 'Curated anime art'
        },
        'linux': {
            'icon': '🐧',
            'url': 'https://github.com/polluxau/linuxnext-wallpapers',
            'branch': 'main',
            'description': 'Linux desktop art'
        },
        'mixed': {
            'icon': '🌟',
            'url': 'https://github.com/makccr/wallpapers',
            'branch': 'main',
            'description': 'Diverse styles'
        },
        'desktop': {
            'icon': '💻',
            'url': 'https://github.com/port19x/Wallpapers',
            'branch': 'main',
            'description': 'Minimalist desktop'
        },
        'gaming': {
            'icon': '🎮',
            'url': 'https://github.com/ryan4yin/wallpapers',
            'branch': 'main',
            'description': 'Gaming-inspired art'
        },
        'photos': {
            'icon': '📷',
            'url': 'https://github.com/linuxdotexe/wallpapers',
            'branch': 'main',
            'description': 'Professional photography'
        },
        'digital': {
            'icon': '🖥️',
            'url': 'https://github.com/0xb0rn3/wallpapers',
            'branch': 'main',
            'description': 'Digital creations'
        }
    }
    
    def __init__(self, butterfly_dir: str = None):
        """Initialize WallPimp with configuration"""
        # Load saved directory or use provided/default
        if butterfly_dir:
            self.butterfly_dir = Path(butterfly_dir)
        else:
            saved_dir = self._load_directory_config()
            self.butterfly_dir = Path(saved_dir)
        
        # Create butterfly directory first
        self.butterfly_dir.mkdir(parents=True, exist_ok=True)
        
        # Setup logging
        self._setup_butterfly_logging()
        
        # Setup HTTP session with proper headers
        self.butterfly_session = requests.Session()
        self.butterfly_session.headers.update({
            'User-Agent': 'WallPimp-Wallpaper-Manager (https://github.com/0xb0rn3/wallpimp)'
        })
        
        # Load cache for tracking downloaded files
        self.butterfly_cache_file = self.butterfly_dir / '.wallpimp_cache.json'
        self.butterfly_cache = self._load_butterfly_cache()
        
        # Statistics tracking
        self.butterfly_stats = {
            'downloaded': 0,
            'skipped': 0,
            'failed': 0,
            'total_size': 0
        }
        
        # Paintbrush environment detection
        self.paintbrush_env = PaintbrushEnvironmentWizard.detect_paintbrush_environment()
    
    def _load_directory_config(self) -> str:
        """Load directory configuration from config file"""
        config_file = Path.home() / '.config' / 'wallpimp' / 'config.json'
        
        if config_file.exists():
            try:
                with open(config_file, 'r') as f:
                    config = json.load(f)
                    return config.get('default_dir', str(Path.home() / 'Pictures'))
            except:
                pass
        
        return str(Path.home() / 'Pictures')
    
    def _save_directory_config(self, directory_path: str):
        """Save directory configuration to config file"""
        config_dir = Path.home() / '.config' / 'wallpimp'
        config_dir.mkdir(parents=True, exist_ok=True)
        config_file = config_dir / 'config.json'
        
        # Load existing config or create new
        config = {}
        if config_file.exists():
            try:
                with open(config_file, 'r') as f:
                    config = json.load(f)
            except:
                pass
        
        config['default_dir'] = directory_path
        config['consolidate_downloads'] = True
        
        try:
            with open(config_file, 'w') as f:
                json.dump(config, f, indent=2)
            print(f"{Fore.GREEN}Configuration saved{Style.RESET_ALL}")
        except Exception as e:
            print(f"{Fore.YELLOW}Warning: Could not save config: {e}{Style.RESET_ALL}")
    
    def setup_consolidation_directory(self):
        """Setup or change the consolidation directory preference"""
        print(f"\n{Fore.CYAN}📁 Wallpaper Directory Setup{Style.RESET_ALL}")
        print("-" * 40)
        
        current_dir = str(self.butterfly_dir)
        print(f"Current directory: {Fore.BLUE}{current_dir}{Style.RESET_ALL}")
        
        # Ask if user wants to change directory
        change_dir = input(f"\n{Fore.YELLOW}Change wallpaper directory? (y/N): {Style.RESET_ALL}").strip().lower()
        
        if change_dir == 'y':
            new_dir = input(f"{Fore.GREEN}Enter new directory path: {Style.RESET_ALL}").strip()
            
            if new_dir:
                # Expand user path and validate
                new_path = Path(new_dir).expanduser()
                
                try:
                    new_path.mkdir(parents=True, exist_ok=True)
                    self.butterfly_dir = new_path
                    print(f"{Fore.GREEN}✓ Directory set to: {new_path}{Style.RESET_ALL}")
                    
                    # Update config
                    self._save_directory_config(str(new_path))
                    return str(new_path)
                    
                except Exception as e:
                    print(f"{Fore.RED}✗ Error creating directory: {e}{Style.RESET_ALL}")
                    return current_dir
        
        return current_dir
    
    def ask_consolidation_preference(self) -> bool:
        """Ask user if they want to consolidate downloads"""
        print(f"\n{Fore.CYAN}📋 Download Organization{Style.RESET_ALL}")
        print("Choose how to organize downloaded wallpapers:")
        print(f"1. Keep in separate folders (default)")
        print(f"2. Consolidate all into main directory")
        
        while True:
            choice = input(f"\n{Fore.GREEN}Enter choice (1 or 2): {Style.RESET_ALL}").strip()
            if choice == '1':
                return False
            elif choice == '2':
                return True
            else:
                print(f"{Fore.RED}Invalid choice. Please enter 1 or 2.{Style.RESET_ALL}")
    
    def consolidate_wallpapers_after_download(self):
        """Consolidate all downloaded wallpapers into main directory"""
        print(f"\n{Fore.CYAN}🔄 Consolidating wallpapers...{Style.RESET_ALL}")
        
        # Get all subdirectories with images
        image_extensions = {'.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp', '.tiff', '.svg'}
        moved_count = 0
        
        for root, dirs, files in os.walk(self.butterfly_dir):
            current_path = Path(root)
            
            # Skip if we're in the main directory
            if current_path == self.butterfly_dir:
                continue
            
            for file in files:
                file_path = current_path / file
                
                if file_path.suffix.lower() in image_extensions:
                    # Create new filename with folder prefix to avoid conflicts
                    folder_name = current_path.relative_to(self.butterfly_dir).parts[0]
                    new_name = f"{folder_name}_{file}"
                    target_path = self.butterfly_dir / new_name
                    
                    # Handle name conflicts
                    counter = 1
                    while target_path.exists():
                        name_parts = file.rsplit('.', 1)
                        if len(name_parts) == 2:
                            new_name = f"{folder_name}_{name_parts[0]}_{counter}.{name_parts[1]}"
                        else:
                            new_name = f"{folder_name}_{file}_{counter}"
                        target_path = self.butterfly_dir / new_name
                        counter += 1
                    
                    try:
                        shutil.move(str(file_path), str(target_path))
                        moved_count += 1
                    except Exception as e:
                        self.butterfly_logger.error(f"Error moving {file_path}: {e}")
        
        # Clean up empty directories
        self._cleanup_empty_dirs()
        
        if moved_count > 0:
            print(f"{Fore.GREEN}✓ Consolidated {moved_count} wallpapers{Style.RESET_ALL}")
        else:
            print(f"{Fore.YELLOW}No wallpapers to consolidate{Style.RESET_ALL}")
    
    def _cleanup_empty_dirs(self):
        """Remove empty subdirectories"""
        for root, dirs, files in os.walk(self.butterfly_dir, topdown=False):
            current_path = Path(root)
            
            # Skip main directory
            if current_path == self.butterfly_dir:
                continue
            
            # Remove if empty
            try:
                if not any(current_path.iterdir()):
                    current_path.rmdir()
            except:
                pass
    
    def _setup_butterfly_logging(self):
        """Setup butterfly logging configuration"""
        butterfly_log_file = self.butterfly_dir / 'wallpimp.log'
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(butterfly_log_file),
                logging.StreamHandler()
            ]
        )
        self.butterfly_logger = logging.getLogger(__name__)
    
    def _load_butterfly_cache(self) -> Dict:
        """Load butterfly cache from file"""
        if self.butterfly_cache_file.exists():
            try:
                with open(self.butterfly_cache_file, 'r') as f:
                    butterfly_cache_data = json.load(f)
                    # Convert downloaded_files back to set if it exists
                    if 'downloaded_files' in butterfly_cache_data and isinstance(butterfly_cache_data['downloaded_files'], list):
                        butterfly_cache_data['downloaded_files'] = set(butterfly_cache_data['downloaded_files'])
                    return butterfly_cache_data
            except (json.JSONDecodeError, IOError):
                self.butterfly_logger.warning("Butterfly cache file corrupted, starting fresh")
        return {'downloaded_files': set()}
    
    def _save_butterfly_cache(self):
        """Save butterfly cache to file"""
        # Convert set to list for JSON serialization
        butterfly_cache_copy = self.butterfly_cache.copy()
        butterfly_cache_copy['downloaded_files'] = list(butterfly_cache_copy['downloaded_files'])
        
        try:
            with open(self.butterfly_cache_file, 'w') as f:
                json.dump(butterfly_cache_copy, f, indent=2)
        except IOError as e:
            self.butterfly_logger.error(f"Failed to save butterfly cache: {e}")
    
    def show_wallpimp_banner(self):
        """Display the WallPimp banner with basic info"""
        banner = f"""
{Fore.CYAN}██╗    ██╗ █████╗ ██╗     ██╗     ██████╗ ██╗███╗   ███╗██████╗ 
██║    ██║██╔══██╗██║     ██║     ██╔══██╗██║████╗ ████║██╔══██╗
██║ █╗ ██║███████║██║     ██║     ██████╔╝██║██╔████╔██║██████╔╝
██║███╗██║██╔══██║██║     ██║     ██╔═══╝ ██║██║╚██╔╝██║██╔═══╝ 
╚███╔███╔╝██║  ██║███████╗███████╗██║     ██║██║ ╚═╝ ██║██║     
 ╚══╝╚══╝ ╚═╝  ╚═╝╚══════╝╚══════╝╚═╝     ╚═╝╚═╝     ╚═╝╚═╝     {Style.RESET_ALL}
                                                                  
{Fore.YELLOW}Universal Linux Wallpaper Manager with Consolidation{Style.RESET_ALL}
{Fore.GREEN}Directory: {self.butterfly_dir}{Style.RESET_ALL}
{Fore.BLUE}Environment: {self.paintbrush_env.upper()}{Style.RESET_ALL}
{Fore.MAGENTA}Developer: 0xb0rn3 | Contact: q4n0@proton.me{Style.RESET_ALL}
{Fore.CYAN}Discord: 0xbv1 | Twitter: 0xbv1 | Instagram: theehiv3{Style.RESET_ALL}
"""
        print(banner)
    
    def list_rainbow_repositories(self):
        """Display all available rainbow repositories"""
        print(f"\n{Fore.CYAN}Available Rainbow Repositories:{Style.RESET_ALL}")
        print("-" * 60)
        
        # Display each repository with its icon, name, and description
        for rainbow_key, rainbow_info in self.rainbow_repositories.items():
            print(f"{rainbow_info['icon']} {Fore.YELLOW}{rainbow_key.upper():<12}{Style.RESET_ALL} - {rainbow_info['description']}")
        
        print(f"\n{Fore.GREEN}Total repositories: {len(self.rainbow_repositories)}{Style.RESET_ALL}")
        print(f"{Fore.CYAN}Use repository name to download from a specific repository{Style.RESET_ALL}")
        print(f"{Fore.CYAN}Use custom URL to download from any GitHub repository{Style.RESET_ALL}")
    
    def get_rainbow_api_url(self, rainbow_url: str, rainbow_branch: str = "main") -> str:
        """Convert GitHub repo URL to API URL for file listing"""
        # Parse the GitHub URL to extract owner and repo name
        parsed = urlparse(rainbow_url)
        path_parts = parsed.path.strip('/').split('/')
        
        if len(path_parts) >= 2:
            owner, repo = path_parts[0], path_parts[1]
            return f"https://api.github.com/repos/{owner}/{repo}/contents?ref={rainbow_branch}"
        else:
            raise ValueError(f"Invalid GitHub URL format: {rainbow_url}")
    
    def fetch_rainbow_contents(self, rainbow_url: str, rainbow_branch: str = "main") -> List[Dict]:
        """Fetch contents of a GitHub repository recursively"""
        try:
            rainbow_api_url = self.get_rainbow_api_url(rainbow_url, rainbow_branch)
            return self._fetch_rainbow_contents_recursive(rainbow_api_url, rainbow_url)
        except Exception as e:
            self.butterfly_logger.error(f"Failed to fetch rainbow contents for {rainbow_url}: {e}")
            return []
    
    def _fetch_rainbow_contents_recursive(self, rainbow_api_url: str, rainbow_url: str, rainbow_path: str = "") -> List[Dict]:
        """Recursively fetch all files from a GitHub repository"""
        rainbow_contents = []
        
        try:
            response = self.butterfly_session.get(rainbow_api_url, timeout=30)
            response.raise_for_status()
            
            rainbow_items = response.json()
            if not isinstance(rainbow_items, list):
                return rainbow_contents
            
            for rainbow_item in rainbow_items:
                if rainbow_item['type'] == 'file':
                    # Check if it's an image file
                    if self._is_rainbow_file(rainbow_item['name']):
                        rainbow_contents.append({
                            'name': rainbow_item['name'],
                            'download_url': rainbow_item['download_url'],
                            'size': rainbow_item['size'],
                            'path': rainbow_path + rainbow_item['name'] if rainbow_path else rainbow_item['name'],
                            'repo_url': rainbow_url
                        })
                elif rainbow_item['type'] == 'dir':
                    # Recursively fetch directory contents
                    rainbow_subdir_contents = self._fetch_rainbow_contents_recursive(
                        rainbow_item['url'], 
                        rainbow_url, 
                        rainbow_path + rainbow_item['name'] + "/"
                    )
                    rainbow_contents.extend(rainbow_subdir_contents)
                    
        except requests.exceptions.RequestException as e:
            self.butterfly_logger.error(f"Error fetching {rainbow_api_url}: {e}")
        except (KeyError, TypeError) as e:
            self.butterfly_logger.error(f"Error parsing API response: {e}")
        
        return rainbow_contents
    
    def _is_rainbow_file(self, rainbow_filename: str) -> bool:
        """Check if file is an image based on extension"""
        rainbow_extensions = {'.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp', '.tiff', '.svg'}
        return Path(rainbow_filename).suffix.lower() in rainbow_extensions
    
    def download_rainbow_file(self, rainbow_file_info: Dict, rainbow_repo_name: str) -> bool:
        """Download a single file with progress tracking"""
        # Create a clean folder name from the repo name
        rainbow_file_path = self.butterfly_dir / rainbow_file_info['path']
        rainbow_file_path.parent.mkdir(parents=True, exist_ok=True)
        
        # Check if file already exists and is in cache
        rainbow_cache_key = f"{rainbow_file_info['path']}"
        if rainbow_cache_key in self.butterfly_cache['downloaded_files'] and rainbow_file_path.exists():
            self.butterfly_stats['skipped'] += 1
            return True
        
        try:
            response = self.butterfly_session.get(rainbow_file_info['download_url'], stream=True, timeout=30)
            response.raise_for_status()
            
            rainbow_total_size = int(response.headers.get('content-length', 0))
            
            with open(rainbow_file_path, 'wb') as f:
                if rainbow_total_size > 0:
                    with tqdm(total=rainbow_total_size, unit='B', unit_scale=True, 
                             desc=f"Downloading {rainbow_file_info['name'][:30]}") as pbar:
                        for chunk in response.iter_content(chunk_size=8192):
                            if chunk:
                                f.write(chunk)
                                pbar.update(len(chunk))
                else:
                    # Fallback for unknown content length
                    for chunk in response.iter_content(chunk_size=8192):
                        if chunk:
                            f.write(chunk)
            
            # Verify the downloaded image
            if self._verify_rainbow_image(rainbow_file_path):
                self.butterfly_cache['downloaded_files'].add(rainbow_cache_key)
                self.butterfly_stats['downloaded'] += 1
                self.butterfly_stats['total_size'] += rainbow_file_path.stat().st_size
                return True
            else:
                rainbow_file_path.unlink()  # Remove corrupted file
                self.butterfly_stats['failed'] += 1
                return False
                
        except Exception as e:
            self.butterfly_logger.error(f"Failed to download {rainbow_file_info['name']}: {e}")
            self.butterfly_stats['failed'] += 1
            return False
    
    def _verify_rainbow_image(self, rainbow_file_path: Path) -> bool:
        """Verify that the downloaded file is a valid image"""
        try:
            with Image.open(rainbow_file_path) as img:
                img.verify()
            return True
        except Exception:
            self.butterfly_logger.warning(f"Invalid rainbow image file: {rainbow_file_path}")
            return False
    
    def download_from_rainbow_repo(self, rainbow_url: str, rainbow_branch: str = "main", rainbow_workers: int = 4, rainbow_name: str = None) -> bool:
        """Download all wallpapers from a specific GitHub repository"""
        # Extract repo name for folder organization if not provided
        if not rainbow_name:
            parsed = urlparse(rainbow_url)
            rainbow_name = parsed.path.strip('/').split('/')[-1] if parsed.path else "wallpapers"
        
        print(f"\n🖼️ Fetching wallpapers from {Fore.YELLOW}{rainbow_url}{Style.RESET_ALL}...")
        
        # Fetch repository contents
        rainbow_contents = self.fetch_rainbow_contents(rainbow_url, rainbow_branch)
        
        if not rainbow_contents:
            print(f"{Fore.RED}No wallpapers found in repository{Style.RESET_ALL}")
            return False
        
        print(f"{Fore.GREEN}Found {len(rainbow_contents)} wallpapers{Style.RESET_ALL}")
        
        # Download files using thread pool
        rainbow_success_count = 0
        with ThreadPoolExecutor(max_workers=rainbow_workers) as executor:
            rainbow_futures = {executor.submit(self.download_rainbow_file, rainbow_file_info, rainbow_name): rainbow_file_info 
                      for rainbow_file_info in rainbow_contents}
            
            for rainbow_future in as_completed(rainbow_futures):
                if rainbow_future.result():
                    rainbow_success_count += 1
        
        print(f"\n{Fore.GREEN}Successfully downloaded {rainbow_success_count}/{len(rainbow_contents)} wallpapers{Style.RESET_ALL}")
        return True
    
    def download_rainbow_repo(self, rainbow_key: str, rainbow_workers: int = 4, consolidate: bool = None) -> bool:
        """Download wallpapers from one of our rainbow repositories"""
        if rainbow_key not in self.rainbow_repositories:
            print(f"{Fore.RED}Repository '{rainbow_key}' not found in rainbow list{Style.RESET_ALL}")
            return False
        
        # Ask for consolidation preference if not specified
        if consolidate is None:
            consolidate = self.ask_consolidation_preference()
        
        rainbow_info = self.rainbow_repositories[rainbow_key]
        print(f"\n{rainbow_info['icon']} Starting download from {Fore.YELLOW}{rainbow_key.upper()}{Style.RESET_ALL}")
        print(f"📁 Description: {rainbow_info['description']}")
        
        success = self.download_from_rainbow_repo(
            rainbow_info['url'], 
            rainbow_info['branch'], 
            rainbow_workers, 
            rainbow_key
        )
        
        # Consolidate if requested and download was successful
        if success and consolidate:
            self.consolidate_wallpapers_after_download()
        
        return success
    
    def download_all_rainbow_repos(self, rainbow_workers: int = 4, consolidate: bool = None):
        """Download wallpapers from all rainbow repositories"""
        print(f"\n{Fore.CYAN}Starting bulk download from all rainbow repositories...{Style.RESET_ALL}")
        
        # Ask for consolidation preference if not specified
        if consolidate is None:
            consolidate = self.ask_consolidation_preference()
        
        rainbow_successful_repos = 0
        rainbow_total_repos = len(self.rainbow_repositories)
        
        for i, rainbow_key in enumerate(self.rainbow_repositories, 1):
            print(f"\n{Fore.MAGENTA}[{i}/{rainbow_total_repos}] Processing {rainbow_key}...{Style.RESET_ALL}")
            
            if self.download_rainbow_repo(rainbow_key, rainbow_workers, False):  # Don't consolidate per repo
                rainbow_successful_repos += 1
            
            # Save cache after each repository
            self._save_butterfly_cache()
            
            # Small delay between repositories to be respectful to GitHub API
            time.sleep(1)
        
        # Consolidate all at once if requested
        if consolidate:
            self.consolidate_wallpapers_after_download()
        
        print(f"\n{Fore.GREEN}Completed downloads from {rainbow_successful_repos}/{rainbow_total_repos} repositories{Style.RESET_ALL}")
        self.show_butterfly_statistics()
    
    def show_butterfly_statistics(self):
        """Display download statistics"""
        print(f"\n{Fore.CYAN}Download Statistics:{Style.RESET_ALL}")
        print("-" * 40)
        print(f"📥 Downloaded: {Fore.GREEN}{self.butterfly_stats['downloaded']}{Style.RESET_ALL}")
        print(f"⏭️  Skipped: {Fore.YELLOW}{self.butterfly_stats['skipped']}{Style.RESET_ALL}")
        print(f"❌ Failed: {Fore.RED}{self.butterfly_stats['failed']}{Style.RESET_ALL}")
        print(f"💾 Total Size: {Fore.CYAN}{self._format_butterfly_bytes(self.butterfly_stats['total_size'])}{Style.RESET_ALL}")
        print(f"📁 Storage Path: {Fore.BLUE}{self.butterfly_dir}{Style.RESET_ALL}")
    
    def _format_butterfly_bytes(self, butterfly_bytes_count: int) -> str:
        """Format bytes to human readable format"""
        for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
            if butterfly_bytes_count < 1024.0:
                return f"{butterfly_bytes_count:.1f} {unit}"
            butterfly_bytes_count /= 1024.0
        return f"{butterfly_bytes_count:.1f} PB"
    
    def cleanup_butterfly_cache(self):
        """Clean up cache and remove orphaned entries"""
        butterfly_cleaned_count = 0
        if 'downloaded_files' in self.butterfly_cache:
            for butterfly_cache_key in list(self.butterfly_cache['downloaded_files']):
                butterfly_file_path = self.butterfly_dir / butterfly_cache_key
                if not butterfly_file_path.exists():
                    self.butterfly_cache['downloaded_files'].discard(butterfly_cache_key)
                    butterfly_cleaned_count += 1
        
        if butterfly_cleaned_count > 0:
            print(f"{Fore.GREEN}Cleaned {butterfly_cleaned_count} orphaned cache entries{Style.RESET_ALL}")
            self._save_butterfly_cache()
    
    def __del__(self):
        """Cleanup when object is destroyed"""
        if hasattr(self, 'butterfly_cache'):
            self._save_butterfly_cache()

def parse_carousel_interval(carousel_interval_str: str) -> int:
    """Parse carousel interval string to seconds"""
    if not carousel_interval_str:
        return 0
    
    # Pattern to match time components
    carousel_pattern = r'(\d+)([smh])'
    carousel_matches = re.findall(carousel_pattern, carousel_interval_str.lower())
    
    if not carousel_matches:
        # Try to parse as plain number (assume seconds)
        try:
            return int(carousel_interval_str)
        except ValueError:
            raise ValueError(f"Invalid carousel interval format: {carousel_interval_str}")
    
    carousel_total_seconds = 0
    for carousel_value, carousel_unit in carousel_matches:
        carousel_value = int(carousel_value)
        if carousel_unit == 's':
            carousel_total_seconds += carousel_value
        elif carousel_unit == 'm':
            carousel_total_seconds += carousel_value * 60
        elif carousel_unit == 'h':
            carousel_total_seconds += carousel_value * 3600
    
    return carousel_total_seconds

def check_for_butterfly_updates():
    """Check for updates from the GitHub repository"""
    try:
        print(f"{Fore.CYAN}Checking for updates...{Style.RESET_ALL}")
        response = requests.get("https://api.github.com/repos/0xb0rn3/wallpimp/releases/latest", timeout=10)
        if response.status_code == 200:
            latest_release = response.json()
            current_version = "v1.0.0"  # You can store this in a config file
            latest_version = latest_release.get('tag_name', 'Unknown')
            
            if latest_version != current_version:
                print(f"{Fore.YELLOW}Update available: {latest_version} (current: {current_version}){Style.RESET_ALL}")
                print(f"{Fore.CYAN}Visit: https://github.com/0xb0rn3/wallpimp for the latest version{Style.RESET_ALL}")
                return True
            else:
                print(f"{Fore.GREEN}You are running the latest version: {current_version}{Style.RESET_ALL}")
        else:
            print(f"{Fore.YELLOW}Unable to check for updates{Style.RESET_ALL}")
    except Exception as e:
        print(f"{Fore.YELLOW}Update check failed: {e}{Style.RESET_ALL}")
    
    return False

def butterfly_interactive_setup():
    """Interactive setup for wallpaper carousel"""
    print(f"\n{Fore.CYAN}🎨 WallPimp Interactive Setup{Style.RESET_ALL}")
    print("=" * 50)
    
    # Detect paintbrush environment
    paintbrush_env = PaintbrushEnvironmentWizard.detect_paintbrush_environment()
    print(f"{Fore.BLUE}Detected Environment: {paintbrush_env.upper()}{Style.RESET_ALL}")
    
    # Ask for wallpaper directory
    butterfly_default_dir = str(Path.home() / 'Pictures')
    butterfly_wallpaper_dir = input(f"\n📁 Enter wallpaper directory (default: {butterfly_default_dir}): ").strip()
    if not butterfly_wallpaper_dir:
        butterfly_wallpaper_dir = butterfly_default_dir
    
    butterfly_wallpaper_path = Path(butterfly_wallpaper_dir)
    if not butterfly_wallpaper_path.exists():
        print(f"{Fore.RED}Directory doesn't exist: {butterfly_wallpaper_path}{Style.RESET_ALL}")
        return None, None, None
    
    # Check for images in directory
    butterfly_image_extensions = {'.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp', '.tiff', '.svg'}
    butterfly_image_count = sum(1 for ext in butterfly_image_extensions 
                     for _ in butterfly_wallpaper_path.glob(f'*{ext}'))
    
    if butterfly_image_count == 0:
        print(f"{Fore.YELLOW}No images found in {butterfly_wallpaper_path}{Style.RESET_ALL}")
        print(f"{Fore.CYAN}You can download wallpapers first using repository downloads{Style.RESET_ALL}")
        return None, None, None
    
    print(f"{Fore.GREEN}Found {butterfly_image_count} images in directory{Style.RESET_ALL}")
    
    # Ask for mode (static or carousel)
    print(f"\n🔄 Choose wallpaper mode:")
    print(f"1. Static wallpaper (set once)")
    print(f"2. Carousel (change automatically)")
    
    while True:
        butterfly_mode_choice = input("\nEnter choice (1 or 2): ").strip()
        if butterfly_mode_choice in ['1', '2']:
            break
        print(f"{Fore.RED}Invalid choice. Please enter 1 or 2.{Style.RESET_ALL}")
    
    if butterfly_mode_choice == '1':
        return butterfly_wallpaper_dir, 'static', 0
    
    # Ask for carousel interval
    print(f"\n⏱️  Enter carousel interval:")
    print(f"Examples: 30s (30 seconds), 5m (5 minutes), 1h (1 hour)")
    print(f"Advanced: 1h 30m 45s (1 hour 30 minutes 45 seconds)")
    
    while True:
        butterfly_interval_str = input("Interval: ").strip()
        try:
            butterfly_interval_seconds = parse_carousel_interval(butterfly_interval_str)
            if butterfly_interval_seconds < 1:
                print(f"{Fore.RED}Interval must be at least 1 second{Style.RESET_ALL}")
                continue
            break
        except ValueError as e:
            print(f"{Fore.RED}{e}{Style.RESET_ALL}")
    
    return butterfly_wallpaper_dir, 'carousel', butterfly_interval_seconds

def butterfly_interactive_menu():
    """Interactive menu for WallPimp"""
    while True:
        print(f"\n{Fore.CYAN}🎨 WallPimp Interactive Menu{Style.RESET_ALL}")
        print("=" * 50)
        print(f"{Fore.YELLOW}1.{Style.RESET_ALL} Download wallpapers from repository")
        print(f"{Fore.YELLOW}2.{Style.RESET_ALL} Download from all repositories")
        print(f"{Fore.YELLOW}3.{Style.RESET_ALL} Download from custom URL")
        print(f"{Fore.YELLOW}4.{Style.RESET_ALL} Set static wallpaper")
        print(f"{Fore.YELLOW}5.{Style.RESET_ALL} Start carousel mode")
        print(f"{Fore.YELLOW}6.{Style.RESET_ALL} Enable autostart carousel")
        print(f"{Fore.YELLOW}7.{Style.RESET_ALL} Disable autostart")
        print(f"{Fore.YELLOW}8.{Style.RESET_ALL} Setup wallpaper directory")
        print(f"{Fore.YELLOW}9.{Style.RESET_ALL} Consolidate wallpapers")
        print(f"{Fore.YELLOW}10.{Style.RESET_ALL} Clean cache")
        print(f"{Fore.YELLOW}11.{Style.RESET_ALL} View repositories")
        print(f"{Fore.YELLOW}12.{Style.RESET_ALL} Check for updates")
        print(f"{Fore.YELLOW}0.{Style.RESET_ALL} Exit")
        
        butterfly_choice = input(f"\n{Fore.GREEN}Enter your choice: {Style.RESET_ALL}").strip()
        
        if butterfly_choice == '1':
            butterfly_menu_download_repo()
        elif butterfly_choice == '2':
            butterfly_menu_download_all()
        elif butterfly_choice == '3':
            butterfly_menu_download_url()
        elif butterfly_choice == '4':
            butterfly_menu_static_wallpaper()
        elif butterfly_choice == '5':
            butterfly_menu_carousel()
        elif butterfly_choice == '6':
            butterfly_menu_enable_autostart()
        elif butterfly_choice == '7':
            butterfly_menu_disable_autostart()
        elif butterfly_choice == '8':
            butterfly_menu_setup_directory()
        elif butterfly_choice == '9':
            butterfly_menu_consolidate()
        elif butterfly_choice == '10':
            butterfly_menu_clean_cache()
        elif butterfly_choice == '11':
            butterfly_menu_view_repos()
        elif butterfly_choice == '12':
            butterfly_menu_check_updates()
        elif butterfly_choice == '0':
            print(f"{Fore.GREEN}Thank you for using WallPimp! 👋{Style.RESET_ALL}")
            break
        else:
            print(f"{Fore.RED}Invalid choice. Please try again.{Style.RESET_ALL}")

def butterfly_menu_download_repo():
    """Menu option to download from repository"""
    wallpimp = WallPimp()
    wallpimp.list_rainbow_repositories()
    
    butterfly_repo_name = input(f"\n{Fore.GREEN}Enter repository name: {Style.RESET_ALL}").strip().lower()
    if butterfly_repo_name in wallpimp.rainbow_repositories:
        butterfly_workers = int(input(f"{Fore.GREEN}Enter number of workers (default 4): {Style.RESET_ALL}").strip() or "4")
        wallpimp.download_rainbow_repo(butterfly_repo_name, butterfly_workers)
        wallpimp.show_butterfly_statistics()
    else:
        print(f"{Fore.RED}Repository not found!{Style.RESET_ALL}")

def butterfly_menu_download_all():
    """Menu option to download from all repositories"""
    wallpimp = WallPimp()
    butterfly_confirm = input(f"{Fore.YELLOW}This will download from ALL repositories. Continue? (y/N): {Style.RESET_ALL}").strip().lower()
    if butterfly_confirm == 'y':
        butterfly_workers = int(input(f"{Fore.GREEN}Enter number of workers (default 4): {Style.RESET_ALL}").strip() or "4")
        wallpimp.download_all_rainbow_repos(butterfly_workers)

def butterfly_menu_download_url():
    """Menu option to download from custom URL"""
    wallpimp = WallPimp()
    butterfly_url = input(f"{Fore.GREEN}Enter GitHub repository URL: {Style.RESET_ALL}").strip()
    if butterfly_url:
        butterfly_branch = input(f"{Fore.GREEN}Enter branch (default main): {Style.RESET_ALL}").strip() or "main"
        butterfly_workers = int(input(f"{Fore.GREEN}Enter number of workers (default 4): {Style.RESET_ALL}").strip() or "4")
        wallpimp.download_from_rainbow_repo(butterfly_url, butterfly_branch, butterfly_workers)
        wallpimp.show_butterfly_statistics()

def butterfly_menu_static_wallpaper():
    """Menu option to set static wallpaper"""
    butterfly_dir = input(f"{Fore.GREEN}Enter wallpaper directory (default ~/Pictures): {Style.RESET_ALL}").strip() or str(Path.home() / 'Pictures')
    try:
        carousel_manager = CarouselManager(butterfly_dir, 0)
        carousel_manager.set_static_canvas()
    except Exception as e:
        print(f"{Fore.RED}Error: {e}{Style.RESET_ALL}")

def butterfly_menu_carousel():
    """Menu option to start carousel"""
    butterfly_dir = input(f"{Fore.GREEN}Enter wallpaper directory (default ~/Pictures): {Style.RESET_ALL}").strip() or str(Path.home() / 'Pictures')
    butterfly_interval = input(f"{Fore.GREEN}Enter interval (e.g., 30s, 5m, 1h): {Style.RESET_ALL}").strip()
    
    try:
        butterfly_interval_seconds = parse_carousel_interval(butterfly_interval)
        carousel_manager = CarouselManager(butterfly_dir, butterfly_interval_seconds)
        
        # Handle graceful shutdown
        def butterfly_signal_handler(signum, frame):
            print(f"\n{Fore.YELLOW}Stopping carousel...{Style.RESET_ALL}")
            carousel_manager.stop_carousel()
            sys.exit(0)
        
        signal.signal(signal.SIGINT, butterfly_signal_handler)
        signal.signal(signal.SIGTERM, butterfly_signal_handler)
        
        carousel_manager.start_carousel()
        
        print(f"{Fore.CYAN}Carousel running... Press Ctrl+C to stop{Style.RESET_ALL}")
        while True:
            time.sleep(1)
            
    except Exception as e:
        print(f"{Fore.RED}Error: {e}{Style.RESET_ALL}")

def butterfly_menu_enable_autostart():
    """Menu option to enable autostart"""
    butterfly_dir = input(f"{Fore.GREEN}Enter wallpaper directory (default ~/Pictures): {Style.RESET_ALL}").strip() or str(Path.home() / 'Pictures')
    butterfly_interval = input(f"{Fore.GREEN}Enter interval (e.g., 10m): {Style.RESET_ALL}").strip() or "10m"
    
    butterfly_script_path = os.path.abspath(__file__)
    AutostartWizard.create_autostart_butterfly(butterfly_script_path, butterfly_dir, butterfly_interval, 'carousel')

def butterfly_menu_disable_autostart():
    """Menu option to disable autostart"""
    AutostartWizard.remove_autostart_butterfly()

def butterfly_menu_setup_directory():
    """Menu option to setup wallpaper directory"""
    wallpimp = WallPimp()
    wallpimp.setup_consolidation_directory()

def butterfly_menu_consolidate():
    """Menu option to consolidate existing wallpapers"""
    butterfly_dir = input(f"{Fore.GREEN}Enter wallpaper directory (default ~/Pictures): {Style.RESET_ALL}").strip() or str(Path.home() / 'Pictures')
    wallpimp = WallPimp(butterfly_dir)
    wallpimp.consolidate_wallpapers_after_download()

def butterfly_menu_clean_cache():
    """Menu option to clean cache"""
    wallpimp = WallPimp()
    wallpimp.cleanup_butterfly_cache()

def butterfly_menu_view_repos():
    """Menu option to view repositories"""
    wallpimp = WallPimp()
    wallpimp.list_rainbow_repositories()

def butterfly_menu_check_updates():
    """Menu option to check for updates"""
    check_for_butterfly_updates()

def butterfly_first_run_setup():
    """First run setup"""
    butterfly_config_file = Path.home() / '.config' / 'wallpimp' / 'config.json'
    butterfly_config_file.parent.mkdir(parents=True, exist_ok=True)
    
    if not butterfly_config_file.exists():
        print(f"{Fore.CYAN}🎉 Welcome to WallPimp! First time setup...{Style.RESET_ALL}")
        
        # Check for updates
        butterfly_update_choice = input(f"{Fore.YELLOW}Check for updates? (Y/n): {Style.RESET_ALL}").strip().lower()
        if butterfly_update_choice != 'n':
            check_for_butterfly_updates()
        
        # Create basic config
        butterfly_config = {
            'first_run': False,
            'default_dir': str(Path.home() / 'Pictures'),
            'check_updates': butterfly_update_choice != 'n'
        }
        
        with open(butterfly_config_file, 'w') as f:
            json.dump(butterfly_config, f, indent=2)
        
        print(f"{Fore.GREEN}Setup complete! Starting interactive menu...{Style.RESET_ALL}")
        return True
    
    # Load existing config and check for updates if enabled
    try:
        with open(butterfly_config_file, 'r') as f:
            butterfly_config = json.load(f)
        
        if butterfly_config.get('check_updates', True):
            butterfly_update_choice = input(f"{Fore.YELLOW}Check for updates? (Y/n): {Style.RESET_ALL}").strip().lower()
            if butterfly_update_choice != 'n':
                check_for_butterfly_updates()
    except:
        pass
    
    return False

def main():
    """Main entry point for WallPimp"""
    parser = argparse.ArgumentParser(
        description='WallPimp - Universal Linux Wallpaper Manager with Consolidation',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  ./wallpimp                         # Interactive menu
  ./wallpimp --repo anime            # Download anime wallpapers
  ./wallpimp --all                   # Download from all repositories
  ./wallpimp --url https://github.com/user/wallpapers
  ./wallpimp --static --dir ~/Pictures    # Set random static wallpaper
  ./wallpimp --carousel --dir ~/Pictures --interval 5m
  ./wallpimp --enable-autostart --dir ~/Pictures --interval 10m
        """
    )
    
    # Download options
    butterfly_download_group = parser.add_argument_group('Download Options')
    butterfly_download_group.add_argument('--dir', type=str, help='Download/wallpaper directory')
    butterfly_download_group.add_argument('--repo', type=str, help='Download from repository')
    butterfly_download_group.add_argument('--url', type=str, help='Download from GitHub repository URL')
    butterfly_download_group.add_argument('--branch', type=str, default='main', help='Repository branch (default: main)')
    butterfly_download_group.add_argument('--list', action='store_true', help='List repositories')
    butterfly_download_group.add_argument('--all', action='store_true', help='Download from all repositories')
    butterfly_download_group.add_argument('--workers', type=int, default=4, help='Download workers (default: 4)')
    butterfly_download_group.add_argument('--cleanup', action='store_true', help='Clean cache')
    butterfly_download_group.add_argument('--consolidate', action='store_true', help='Consolidate downloads into main directory')
    
    # Wallpaper management options
    butterfly_wallpaper_group = parser.add_argument_group('Wallpaper Management')
    butterfly_wallpaper_group.add_argument('--setup', action='store_true', help='Interactive setup')
    butterfly_wallpaper_group.add_argument('--static', action='store_true', help='Set random static wallpaper')
    butterfly_wallpaper_group.add_argument('--carousel', action='store_true', help='Start carousel mode')
    butterfly_wallpaper_group.add_argument('--interval', type=str, help='Carousel interval (e.g., 30s, 5m, 1h)')
    butterfly_wallpaper_group.add_argument('--image', type=str, help='Specific image path for static mode')
    butterfly_wallpaper_group.add_argument('--setup-dir', action='store_true', help='Setup wallpaper directory')
    butterfly_wallpaper_group.add_argument('--consolidate-existing', action='store_true', help='Consolidate existing wallpapers')
    
    # Autostart options
    butterfly_autostart_group = parser.add_argument_group('Autostart Management')
    butterfly_autostart_group.add_argument('--enable-autostart', action='store_true', help='Enable autostart')
    butterfly_autostart_group.add_argument('--disable-autostart', action='store_true', help='Disable autostart')
    
    args = parser.parse_args()
    
    # If no arguments provided, run interactive mode
    if len(sys.argv) == 1:
        # First run check
        butterfly_first_run = butterfly_first_run_setup()
        
        # Initialize WallPimp and show banner
        wallpimp = WallPimp()
        wallpimp.show_wallpimp_banner()
        
        # Start interactive menu
        butterfly_interactive_menu()
        return
    
    # Validate argument combinations for command line mode
    butterfly_main_actions = [
        args.repo, args.url, args.list, args.all, args.cleanup,
        args.setup, args.static, args.carousel, 
        args.enable_autostart, args.disable_autostart,
        args.setup_dir, args.consolidate_existing
    ]
    
    if sum(bool(action) for action in butterfly_main_actions) > 1:
        print(f"{Fore.RED}Error: Please specify only one main action{Style.RESET_ALL}")
        sys.exit(1)
    
    # Initialize WallPimp
    wallpimp = WallPimp(butterfly_dir=args.dir)
    wallpimp.show_wallpimp_banner()
    
    try:
        # Handle download operations
        if args.list:
            wallpimp.list_rainbow_repositories()
        elif args.cleanup:
            wallpimp.cleanup_butterfly_cache()
        elif args.all:
            wallpimp.download_all_rainbow_repos(rainbow_workers=args.workers, consolidate=args.consolidate)
        elif args.repo:
            wallpimp.download_rainbow_repo(args.repo.lower(), rainbow_workers=args.workers, consolidate=args.consolidate)
        elif args.url:
            success = wallpimp.download_from_rainbow_repo(args.url, args.branch, rainbow_workers=args.workers)
            if success and args.consolidate:
                wallpimp.consolidate_wallpapers_after_download()
        
        # Handle directory setup
        elif args.setup_dir:
            wallpimp.setup_consolidation_directory()
        elif args.consolidate_existing:
            wallpimp.consolidate_wallpapers_after_download()
        
        # Handle wallpaper management
        elif args.setup:
            butterfly_wallpaper_dir, butterfly_mode, butterfly_interval = butterfly_interactive_setup()
            if butterfly_wallpaper_dir:
                if butterfly_mode == 'static':
                    carousel_manager = CarouselManager(butterfly_wallpaper_dir, 0)
                    carousel_manager.set_static_canvas()
                else:
                    # Create autostart entry
                    butterfly_script_path = os.path.abspath(__file__)
                    AutostartWizard.create_autostart_butterfly(
                        butterfly_script_path, butterfly_wallpaper_dir, f"{butterfly_interval}s", 'carousel'
                    )
                    print(f"{Fore.GREEN}Carousel will start automatically on next login{Style.RESET_ALL}")
        
        elif args.static:
            if not args.dir:
                print(f"{Fore.RED}Error: --dir is required for static mode{Style.RESET_ALL}")
                sys.exit(1)
            
            carousel_manager = CarouselManager(args.dir, 0)
            carousel_manager.set_static_canvas(args.image)
        
        elif args.carousel:
            if not args.dir:
                print(f"{Fore.RED}Error: --dir is required for carousel mode{Style.RESET_ALL}")
                sys.exit(1)
            if not args.interval:
                print(f"{Fore.RED}Error: --interval is required for carousel mode{Style.RESET_ALL}")
                sys.exit(1)
            
            try:
                butterfly_interval_seconds = parse_carousel_interval(args.interval)
                carousel_manager = CarouselManager(args.dir, butterfly_interval_seconds)
                
                # Handle graceful shutdown
                def butterfly_signal_handler(signum, frame):
                    print(f"\n{Fore.YELLOW}Stopping carousel...{Style.RESET_ALL}")
                    carousel_manager.stop_carousel()
                    sys.exit(0)
                
                signal.signal(signal.SIGINT, butterfly_signal_handler)
                signal.signal(signal.SIGTERM, butterfly_signal_handler)
                
                carousel_manager.start_carousel()
                
                # Keep the program running
                while True:
                    time.sleep(1)
                    
            except ValueError as e:
                print(f"{Fore.RED}Error parsing interval: {e}{Style.RESET_ALL}")
                sys.exit(1)
            except Exception as e:
                print(f"{Fore.RED}Error starting carousel: {e}{Style.RESET_ALL}")
                sys.exit(1)
        
        # Handle autostart management
        elif args.enable_autostart:
            if not args.dir:
                print(f"{Fore.RED}Error: --dir is required for autostart{Style.RESET_ALL}")
                sys.exit(1)
            
            butterfly_script_path = os.path.abspath(__file__)
            if args.interval:
                AutostartWizard.create_autostart_butterfly(
                    butterfly_script_path, args.dir, args.interval, 'carousel'
                )
            else:
                AutostartWizard.create_autostart_butterfly(
                    butterfly_script_path, args.dir, '10m', 'static'
                )
        
        elif args.disable_autostart:
            AutostartWizard.remove_autostart_butterfly()
        
        else:
            # No arguments provided - this shouldn't happen due to earlier check
            print(f"{Fore.CYAN}Use ./wallpimp --help for command line options or ./wallpimp for interactive menu{Style.RESET_ALL}")
    
    except KeyboardInterrupt:
        print(f"\n{Fore.YELLOW}Operation cancelled by user{Style.RESET_ALL}")
    except Exception as e:
        print(f"\n{Fore.RED}An error occurred: {e}{Style.RESET_ALL}")
        if hasattr(wallpimp, 'butterfly_logger'):
            wallpimp.butterfly_logger.error(f"Unexpected error: {e}")
    finally:
        # Always show statistics for download operations
        if any([args.repo, args.url, args.all]):
            wallpimp.show_butterfly_statistics()

if __name__ == "__main__":
    main()
