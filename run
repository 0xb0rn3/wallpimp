#!/usr/bin/env python3
import sys
import hashlib
import shutil
import tempfile
import asyncio
import platform
import subprocess
import importlib
from pathlib import Path
from typing import Set, Dict
from dataclasses import dataclass
from PIL import Image
from concurrent.futures import ThreadPoolExecutor

# GUI imports (will be checked later)
QtWidgets = importlib.util.find_spec("PySide6.QtWidgets")

@dataclass
class DownloadStats:
    successful_repos: int = 0
    failed_repos: int = 0
    total_processed: int = 0
    duplicates: int = 0

# Check and install missing dependencies before GUI loads
def install_dependencies():
    required = {
        'PySide6': 'pyside6',
        'PIL': 'pillow'
    }
    
    missing = []
    for imp, pkg in required.items():
        if importlib.util.find_spec(imp) is None:
            missing.append(pkg)
    
    if missing:
        from PySide6.QtWidgets import QApplication, QMessageBox
        
        app = QApplication(sys.argv)
        msg = QMessageBox()
        msg.setIcon(QMessageBox.Icon.Critical)
        msg.setWindowTitle("Missing Dependencies")
        msg.setText("Required packages are missing:")
        msg.setInformativeText("\n".join(missing))
        msg.setStandardButtons(
            QMessageBox.StandardButton.Yes | 
            QMessageBox.StandardButton.No
        )
        msg.setDetailedText("Would you like to install them?")
        msg.button(QMessageBox.StandardButton.Yes).setText("Install")
        msg.button(QMessageBox.StandardButton.No).setText("Exit")
        
        response = msg.exec()
        if response == QMessageBox.StandardButton.Yes:
            try:
                subprocess.run([
                    sys.executable, "-m", "pip", "install",
                    "--user", *missing
                ], check=True)
                QMessageBox.information(
                    None, "Success", 
                    "Dependencies installed successfully!\nPlease restart the application."
                )
            except subprocess.CalledProcessError as e:
                QMessageBox.critical(
                    None, "Error",
                    f"Failed to install dependencies:\n{e.stderr or e}"
                )
            sys.exit(0)
        else:
            sys.exit(1)

# Run dependency check before anything else
if not QtWidgets:
    install_dependencies()

# Now import GUI components
from PySide6.QtWidgets import (
    QApplication, QMainWindow, QWidget, QVBoxLayout, QHBoxLayout,
    QLabel, QProgressBar, QPushButton, QFileDialog, QCheckBox, QGridLayout,
    QGroupBox, QScrollArea, QMessageBox
)
from PySide6.QtCore import Qt, QThreadPool, QRunnable, Signal, QObject
from PySide6.QtGui import QPixmap, QIcon, QFont

class WorkerSignals(QObject):
    progress = Signal(int)
    repo_started = Signal(dict)
    repo_finished = Signal(dict, bool)
    image_processed = Signal()
    error = Signal(str)
    finished = Signal()

class WallpaperWorker(QRunnable):
    def __init__(self, repos, save_dir):
        super().__init__()
        self.repos = repos
        self.save_dir = save_dir
        self.signals = WorkerSignals()
        self._is_running = True
        self.processed_hashes: Set[str] = set()
        self.supported_formats = {'.jpg', '.jpeg', '.png', '.gif', '.webp', '.bmp', '.png', '.tiff'}

    def run(self):
        asyncio.run(self._run())

    async def _run(self):
        temp_dir = Path(tempfile.mkdtemp())
        stats = DownloadStats()

        try:
            for repo in self.repos:
                if not self._is_running:
                    break
                
                self.signals.repo_started.emit(repo)
                success = await self.download_repo(repo, temp_dir)
                self.signals.repo_finished.emit(repo, success)
                
                if success:
                    stats.successful_repos += 1
                else:
                    stats.failed_repos += 1

            self.signals.finished.emit()
        except Exception as e:
            self.signals.error.emit(str(e))
        finally:
            shutil.rmtree(temp_dir, ignore_errors=True)

    async def download_repo(self, repo, temp_dir):
        repo_name = repo['url'].split('/')[-1]
        repo_path = temp_dir / repo_name
        
        try:
            process = await asyncio.create_subprocess_exec(
                'git', 'clone', '--depth', '1', 
                '--branch', repo['branch'], 
                repo['url'], str(repo_path)
            )
            
            await process.wait()
            if process.returncode != 0:
                return False
                
            await self.process_directory(repo_path)
            return True
        except Exception:
            return False

    async def process_directory(self, source_dir):
        with ThreadPoolExecutor() as executor:
            tasks = []
            for file_path in source_dir.rglob('*'):
                if file_path.suffix.lower() in self.supported_formats:
                    tasks.append(
                        asyncio.get_event_loop().run_in_executor(
                            executor,
                            self.process_image,
                            file_path
                        )
                    )
            
            for task in asyncio.as_completed(tasks):
                await task
                self.signals.image_processed.emit()

    def process_image(self, source):
        try:
            with open(source, 'rb') as f:
                file_hash = hashlib.sha256(f.read()).hexdigest()
            
            if file_hash in self.processed_hashes:
                return False
                
            with Image.open(source) as img:
                width, height = img.size
                if width < 1920 or height < 1080:
                    return False
                
                new_filename = f"{file_hash}{source.suffix}"
                output_path = self.save_dir / new_filename
                img.save(output_path, quality=95)
                self.processed_hashes.add(file_hash)
                return True
        except Exception:
            return False

    def stop(self):
        self._is_running = False

class WallpaperGUI(QMainWindow):
    REPOSITORIES = [
        {
            'name': 'Minimalist Walls',
            'url': 'https://github.com/dharmx/walls',
            'branch': 'main',
            'icon': 'ðŸŽ¨'
        },
        {
            'name': 'Anime Collection',
            'url': 'https://github.com/HENTAI-CODER/Anime-Wallpaper',
            'branch': 'main',
            'icon': 'ðŸŒ¸'
        },
        # ... add other repositories
    ]

    def __init__(self):
        super().__init__()
        self.worker = None
        self.thread_pool = QThreadPool()
        self.init_ui()
        self.setWindowTitle("WallPimp GUI")
        self.setMinimumSize(800, 600)

    def init_ui(self):
        main_widget = QWidget()
        main_layout = QVBoxLayout()

        # Header
        header = QLabel("WallPimp - Intelligent Wallpaper Collector")
        header.setFont(QFont("Arial", 16, QFont.Bold))
        header.setAlignment(Qt.AlignCenter)
        main_layout.addWidget(header)

        # Repository Selection
        repo_group = QGroupBox("Select Repositories")
        repo_layout = QGridLayout()
        
        self.repo_checkboxes = []
        for i, repo in enumerate(self.REPOSITORIES):
            cb = QCheckBox(f"{repo['icon']} {repo['name']}")
            cb.setChecked(True)
            repo_layout.addWidget(cb, i//2, i%2)
            self.repo_checkboxes.append(cb)
        
        repo_group.setLayout(repo_layout)
        main_layout.addWidget(repo_group)

        # Progress Section
        self.progress_bars = {}
        progress_group = QGroupBox("Download Progress")
        progress_layout = QVBoxLayout()
        
        for repo in self.REPOSITORIES:
            pb = QProgressBar()
            pb.setRange(0, 100)
            pb.setValue(0)
            pb.setFormat(f"{repo['icon']} {repo['name']} : %p%")
            self.progress_bars[repo['name']] = pb
            progress_layout.addWidget(pb)
        
        progress_group.setLayout(progress_layout)
        main_layout.addWidget(progress_group)

        # Controls
        control_layout = QHBoxLayout()
        
        self.btn_start = QPushButton("Start Download")
        self.btn_start.clicked.connect(self.start_download)
        self.btn_stop = QPushButton("Stop")
        self.btn_stop.clicked.connect(self.stop_download)
        self.btn_stop.setEnabled(False)
        
        self.btn_dir = QPushButton("Choose Folder")
        self.btn_dir.clicked.connect(self.choose_directory)
        self.dir_label = QLabel("Save location: Not selected")
        
        control_layout.addWidget(self.btn_dir)
        control_layout.addWidget(self.dir_label)
        control_layout.addStretch()
        control_layout.addWidget(self.btn_start)
        control_layout.addWidget(self.btn_stop)
        
        main_layout.addLayout(control_layout)

        main_widget.setLayout(main_layout)
        self.setCentralWidget(main_widget)

    def choose_directory(self):
        path = QFileDialog.getExistingDirectory(self, "Select Save Directory")
        if path:
            self.save_dir = Path(path)
            self.dir_label.setText(f"Save location: {path}")

    def start_download(self):
        if not hasattr(self, 'save_dir'):
            QMessageBox.warning(self, "Error", "Please select a save directory first!")
            return

        selected_repos = [
            repo for repo, cb in zip(self.REPOSITORIES, self.repo_checkboxes)
            if cb.isChecked()
        ]
        
        if not selected_repos:
            QMessageBox.warning(self, "Error", "Please select at least one repository!")
            return

        self.worker = WallpaperWorker(selected_repos, self.save_dir)
        self.worker.signals.repo_started.connect(self.repo_started)
        self.worker.signals.repo_finished.connect(self.repo_finished)
        self.worker.signals.image_processed.connect(self.image_processed)
        self.worker.signals.error.connect(self.show_error)
        self.worker.signals.finished.connect(self.download_finished)
        
        self.btn_start.setEnabled(False)
        self.btn_stop.setEnabled(True)
        self.thread_pool.start(self.worker)

    def stop_download(self):
        if self.worker:
            self.worker.stop()
        self.btn_start.setEnabled(True)
        self.btn_stop.setEnabled(False)

    def repo_started(self, repo):
        name = repo['name']
        self.progress_bars[name].setValue(0)

    def repo_finished(self, repo, success):
        name = repo['name']
        self.progress_bars[name].setValue(100)
        color = "green" if success else "red"
        self.progress_bars[name].setStyleSheet(f"QProgressBar::chunk {{ background-color: {color}; }}")

    def image_processed(self):
        pass  # Update per-image progress if needed

    def show_error(self, message):
        QMessageBox.critical(self, "Error", message)

    def download_finished(self):
        self.btn_start.setEnabled(True)
        self.btn_stop.setEnabled(False)
        QMessageBox.information(self, "Complete", "Download finished successfully!")

if __name__ == "__main__":
    app = QApplication(sys.argv)
    window = WallpaperGUI()
    window.show()
    sys.exit(app.exec())
