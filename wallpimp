#!/usr/bin/env python3
"""
WallPimp v2.1 - Cross-Platform Automated Wallpaper Collection Tool
Enhanced version with direct cloning and improved feedback
"""
import os
import sys
import shutil
import subprocess
import platform
from pathlib import Path
import hashlib
import time
from concurrent.futures import ThreadPoolExecutor, as_completed
from typing import List, Set, Dict, Tuple
from tqdm import tqdm

# Configuration
WALLPAPER_REPOS = [
    "https://github.com/dharmx/walls",
    "https://github.com/FrenzyExists/wallpapers",
    "https://github.com/Dreamer-Paul/Anime-Wallpaper",
    "https://github.com/michaelScopic/Wallpapers",
    "https://github.com/ryan4yin/wallpapers",
    "https://github.com/HENTAI-CODER/Anime-Wallpaper",
    "https://github.com/port19x/Wallpapers",
    "https://github.com/k1ng440/Wallpapers",
    "https://github.com/vimfn/walls",
    "https://github.com/expandpi/wallpapers"
]

IMAGE_FORMATS = {'.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp', '.tiff', '.svg', '.heic'}
MAX_IMAGE_SIZE = 50 * 1024 * 1024  # 50MB
MIN_IMAGE_SIZE = 10 * 1024  # 10KB
MAX_RETRIES = 3
CLONE_TIMEOUT = 180  # Increased timeout for cloning

class WallPimp:
    def __init__(self):
        self.output_folder = self._get_default_output_folder()
        self.temp_dir = Path("temp_repos")
        self.processed_hashes: Set[str] = set()
        self.total_wallpapers = 0
        self.successful_repos = 0
        self.pbar = None

    def _get_default_output_folder(self) -> Path:
        """Returns the platform-specific default output folder path"""
        system = platform.system().lower()
        env_var = 'USERPROFILE' if system == 'windows' else 'HOME'
        return Path(os.environ.get(env_var, '')) / 'Pictures' / 'WallPimp'

    def _validate_image(self, filepath: Path) -> bool:
        """Validate image file size and format"""
        try:
            if filepath.suffix.lower() not in IMAGE_FORMATS:
                return False
            file_size = filepath.stat().st_size
            return MIN_IMAGE_SIZE <= file_size <= MAX_IMAGE_SIZE
        except Exception:
            return False

    def _get_file_hash(self, filepath: Path) -> str:
        """Calculate SHA-256 hash of a file"""
        sha256_hash = hashlib.sha256()
        with open(filepath, "rb") as f:
            for byte_block in iter(lambda: f.read(4096), b""):
                sha256_hash.update(byte_block)
        return sha256_hash.hexdigest()

    def _clone_repository(self, repo_url: str, repo_path: Path) -> bool:
        """Clone repository with retry mechanism"""
        for attempt in range(MAX_RETRIES):
            try:
                if attempt > 0:
                    time.sleep(2 ** attempt)
                subprocess.run(
                    ['git', 'clone', '--depth', '1', '--quiet', repo_url, str(repo_path)],
                    check=True, capture_output=True, timeout=CLONE_TIMEOUT
                )
                return True
            except subprocess.SubprocessError:
                continue
        return False

    def process_repository(self, repo_url: str) -> Tuple[int, str]:
        """Process a single repository and collect its wallpapers"""
        repo_name = repo_url.split('/')[-1].replace('.git', '')
        repo_path = self.temp_dir / repo_name
        wallpapers_count = 0
        status_message = ""

        try:
            if not self._clone_repository(repo_url, repo_path):
                return 0, f"⚠️  Failed to clone {repo_name}"

            image_files = []
            for ext in IMAGE_FORMATS:
                image_files.extend(repo_path.glob(f"**/*{ext}"))
                image_files.extend(repo_path.glob(f"**/*{ext.upper()}"))

            for image_file in image_files:
                try:
                    if not self._validate_image(image_file):
                        continue

                    file_hash = self._get_file_hash(image_file)
                    if file_hash in self.processed_hashes:
                        continue

                    new_name = f"{repo_name}_{image_file.name}"
                    destination = self.output_folder / new_name
                    shutil.copy2(image_file, destination)
                    self.processed_hashes.add(file_hash)
                    wallpapers_count += 1

                except Exception:
                    continue

            self.successful_repos += 1
            status_message = f"✓ Downloaded {wallpapers_count} wallpapers from {repo_name}"
            return wallpapers_count, status_message

        except Exception as e:
            status_message = f"⚠️  Error processing {repo_name}: {str(e)}"
            return wallpapers_count, status_message
        finally:
            shutil.rmtree(repo_path, ignore_errors=True)

    def run(self):
        """Main execution method"""
        print("\n╔═══════════════════════════════════════╗")
        print("║           WallPimp v2.1               ║")
        print("╚═══════════════════════════════════════╝\n")

        self.output_folder.mkdir(parents=True, exist_ok=True)
        self.temp_dir.mkdir(exist_ok=True)

        try:
            with ThreadPoolExecutor(max_workers=3) as executor:
                futures = [
                    executor.submit(self.process_repository, repo_url)
                    for repo_url in WALLPAPER_REPOS
                ]
                
                with tqdm(total=len(WALLPAPER_REPOS), 
                         desc="Downloading wallpapers", 
                         bar_format='{desc}: {percentage:3.0f}%|{bar}| {n_fmt}/{total_fmt}',
                         ncols=70) as pbar:
                    for future in as_completed(futures):
                        count, status = future.result()
                        self.total_wallpapers += count
                        print(f"\n{status}")
                        pbar.update(1)

        finally:
            shutil.rmtree(self.temp_dir, ignore_errors=True)

        print(f"\n✨ Collection complete! Downloaded {self.total_wallpapers} wallpapers")
        print(f"📁 Saved to: {self.output_folder}")
        if self.successful_repos < len(WALLPAPER_REPOS):
            print(f"ℹ️  Successfully processed {self.successful_repos} out of {len(WALLPAPER_REPOS)} repositories")

def main():
    """Entry point of the script"""
    try:
        subprocess.run(['git', '--version'], 
                      check=True, 
                      capture_output=True, 
                      timeout=5)
    except Exception:
        print("Error: Git is not installed. Please install Git and try again.")
        sys.exit(1)

    wallpimp = WallPimp()
    wallpimp.run()

if __name__ == "__main__":
    main()
