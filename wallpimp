#!/usr/bin/env python3
"""
WallPimp v2.1 - Cross-Platform Automated Wallpaper Collection Tool
A sophisticated wallpaper collection tool that fetches high-quality wallpapers
from curated GitHub repositories while handling errors gracefully and providing
clear feedback to users.

Developed by ソロックス (oxborn3)
GitHub: https://github.com/0xb0rn3
"""
import os
import sys
import shutil
import subprocess
import platform
from pathlib import Path
import hashlib
import time
from concurrent.futures import ThreadPoolExecutor, as_completed
from typing import List, Set, Dict, Tuple
from tqdm import tqdm

# Configuration constants
WALLPAPER_REPOS = [
    "https://github.com/dharmx/walls",
    "https://github.com/FrenzyExists/wallpapers",
    "https://github.com/Dreamer-Paul/Anime-Wallpaper",
    "https://github.com/michaelScopic/Wallpapers",
    "https://github.com/ryan4yin/wallpapers",
    "https://github.com/HENTAI-CODER/Anime-Wallpaper",
    "https://github.com/port19x/Wallpapers",
    "https://github.com/k1ng440/Wallpapers",
    "https://github.com/vimfn/walls",
    "https://github.com/expandpi/wallpapers"
]

# Supported image formats and size constraints
IMAGE_FORMATS = {'.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp', '.tiff', '.svg', '.heic'}
MAX_IMAGE_SIZE = 500 * 1024 * 1024  # 500MB maximum file size
MIN_IMAGE_SIZE = 1 * 1024         # 1KB minimum file size
MAX_RETRIES = 3                    # Maximum number of retry attempts
CLONE_TIMEOUT = 1800000                # Repository clone timeout in seconds

class WallPimp:
    """
    Main class for the WallPimp wallpaper collection tool.
    Handles downloading, processing, and organizing wallpapers from various repositories.
    """
    
    def __init__(self):
        """Initialize the WallPimp instance with necessary paths and counters."""
        self.output_folder = self._get_default_output_folder()
        self.temp_dir = Path("temp_repos")
        self.processed_hashes: Set[str] = set()
        self.total_wallpapers = 0
        self.successful_repos = 0

    def _get_default_output_folder(self) -> Path:
        """
        Determine the appropriate output folder based on the operating system.
        Returns a Path object pointing to the Pictures/WallPimp directory.
        """
        system = platform.system().lower()
        env_var = 'USERPROFILE' if system == 'windows' else 'HOME'
        return Path(os.environ.get(env_var, '')) / 'Pictures' / 'WallPimp'

    def _validate_image(self, filepath: Path) -> bool:
        """
        Validate an image file based on its extension and size.
        Returns True if the image meets all criteria, False otherwise.
        """
        try:
            if filepath.suffix.lower() not in IMAGE_FORMATS:
                return False
            file_size = filepath.stat().st_size
            return MIN_IMAGE_SIZE <= file_size <= MAX_IMAGE_SIZE
        except Exception:
            return False

    def _get_file_hash(self, filepath: Path) -> str:
        """
        Calculate the SHA-256 hash of a file to prevent duplicates.
        Returns the hexadecimal string representation of the hash.
        """
        sha256_hash = hashlib.sha256()
        with open(filepath, "rb") as f:
            for byte_block in iter(lambda: f.read(4096), b""):
                sha256_hash.update(byte_block)
        return sha256_hash.hexdigest()

    def _clone_repository(self, repo_url: str, repo_path: Path) -> bool:
        """
        Clone a repository with retry mechanism and timeout.
        Returns True if cloning was successful, False otherwise.
        """
        for attempt in range(MAX_RETRIES):
            try:
                if attempt > 0:
                    time.sleep(2 ** attempt)  # Exponential backoff
                subprocess.run(
                    ['git', 'clone', '--depth', '1', '--quiet', repo_url, str(repo_path)],
                    check=True,
                    capture_output=True,
                    timeout=CLONE_TIMEOUT
                )
                return True
            except subprocess.SubprocessError:
                continue
        return False

    def process_repository(self, repo_url: str) -> Tuple[int, str]:
        """
        Process a single repository, collecting and organizing its wallpapers.
        Returns a tuple of (number of wallpapers processed, status message).
        """
        repo_name = repo_url.split('/')[-1].replace('.git', '')
        repo_path = self.temp_dir / repo_name
        wallpapers_count = 0
        status_message = ""

        try:
            # Attempt to clone the repository
            if not self._clone_repository(repo_url, repo_path):
                return 0, f"⚠️  Failed to clone {repo_name}"

            # Collect all image files
            image_files = []
            for ext in IMAGE_FORMATS:
                image_files.extend(repo_path.glob(f"**/*{ext}"))
                image_files.extend(repo_path.glob(f"**/*{ext.upper()}"))

            # Process each image
            for image_file in image_files:
                try:
                    if not self._validate_image(image_file):
                        continue

                    file_hash = self._get_file_hash(image_file)
                    if file_hash in self.processed_hashes:
                        continue

                    new_name = f"{repo_name}_{image_file.name}"
                    destination = self.output_folder / new_name
                    shutil.copy2(image_file, destination)
                    self.processed_hashes.add(file_hash)
                    wallpapers_count += 1

                except Exception:
                    continue

            self.successful_repos += 1
            status_message = f"✓ Downloaded {wallpapers_count} wallpapers from {repo_name}"
            return wallpapers_count, status_message

        except Exception as e:
            status_message = f"⚠️  Error processing {repo_name}: {str(e)}"
            return wallpapers_count, status_message
        finally:
            shutil.rmtree(repo_path, ignore_errors=True)

    def print_banner(self):
        """Display the WallPimp banner with developer information."""
        banner = """
╔══════════════════════════════════════════════════╗
║                 WallPimp v2.1                    ║
║        Developed by ソロックス (oxborn3)          ║
║        https://github.com/0xb0rn3               ║
╚══════════════════════════════════════════════════╝
        """
        print(banner)

    def run(self):
        """
        Main execution method that orchestrates the wallpaper collection process.
        Handles multiple repositories in parallel and provides progress feedback.
        """
        self.print_banner()

        # Create necessary directories
        self.output_folder.mkdir(parents=True, exist_ok=True)
        self.temp_dir.mkdir(exist_ok=True)

        try:
            # Process repositories in parallel
            with ThreadPoolExecutor(max_workers=3) as executor:
                futures = [
                    executor.submit(self.process_repository, repo_url)
                    for repo_url in WALLPAPER_REPOS
                ]
                
                # Display progress bar and status updates
                with tqdm(total=len(WALLPAPER_REPOS), 
                         desc="Downloading 300+ unique-wallpapers please be patient", 
                         bar_format='{desc}: {percentage:3.0f}%|{bar}| {n_fmt}/{total_fmt}',
                         ncols=70) as pbar:
                    for future in as_completed(futures):
                        count, status = future.result()
                        self.total_wallpapers += count
                        print(f"\n{status}")
                        pbar.update(1)

        finally:
            # Clean up temporary files
            shutil.rmtree(self.temp_dir, ignore_errors=True)

        # Display final summary
        print(f"\n✨ Collection complete! Downloaded {self.total_wallpapers} wallpapers")
        print(f"📁 Saved to: {self.output_folder}")
        if self.successful_repos < len(WALLPAPER_REPOS):
            print(f"ℹ️  Successfully processed {self.successful_repos} out of {len(WALLPAPER_REPOS)} repositories")

def check_git_installation():
    """
    Verify that Git is installed and accessible.
    Exits with an error message if Git is not found.
    """
    try:
        subprocess.run(['git', '--version'], 
                      check=True, 
                      capture_output=True, 
                      timeout=5)
        return True
    except Exception:
        print("Error: Git is not installed. Please install Git and try again.")
        sys.exit(1)

def main():
    """Entry point of the script."""
    check_git_installation()
    wallpimp = WallPimp()
    wallpimp.run()

if __name__ == "__main__":
    main()
