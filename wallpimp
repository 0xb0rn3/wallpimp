#!/usr/bin/env python3
"""
WallPimp v2.0 - Cross-Platform Automated Wallpaper Collection Tool
Enhanced version with retry mechanism, improved error handling, and minimal UI
"""
import os
import sys
import shutil
import subprocess
import platform
from pathlib import Path
import hashlib
import time
from concurrent.futures import ThreadPoolExecutor, as_completed
from typing import List, Set, Dict
from tqdm import tqdm
import requests
from urllib.parse import urlparse

# Configuration
WALLPAPER_REPOS = [
    "https://github.com/dharmx/walls",
    "https://github.com/FrenzyExists/wallpapers",
    "https://github.com/Dreamer-Paul/Anime-Wallpaper",
    "https://github.com/michaelScopic/Wallpapers",
    "https://github.com/ryan4yin/wallpapers",
    "https://github.com/HENTAI-CODER/Anime-Wallpaper",
    "https://github.com/port19x/Wallpapers",
    "https://github.com/k1ng440/Wallpapers",
    "https://github.com/vimfn/walls",
    "https://github.com/expandpi/wallpapers"
]

IMAGE_FORMATS = {'.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp', '.tiff', '.svg', '.heic'}
MAX_IMAGE_SIZE = 50 * 1024 * 1024  # 50MB
MIN_IMAGE_SIZE = 10 * 1024  # 10KB
MAX_RETRIES = 3
TIMEOUT = 30

class WallPimp:
    def __init__(self):
        self.output_folder = self._get_default_output_folder()
        self.temp_dir = Path("temp_repos")
        self.processed_hashes: Set[str] = set()
        self.total_wallpapers = 0
        self.successful_repos = 0

    def _get_default_output_folder(self) -> Path:
        """Returns the platform-specific default output folder path"""
        system = platform.system().lower()
        env_var = 'USERPROFILE' if system == 'windows' else 'HOME'
        return Path(os.environ.get(env_var, '')) / 'Pictures' / 'WallPimp'

    def _validate_image(self, filepath: Path) -> bool:
        """Validate image file size and format"""
        try:
            if filepath.suffix.lower() not in IMAGE_FORMATS:
                return False
            file_size = filepath.stat().st_size
            return MIN_IMAGE_SIZE <= file_size <= MAX_IMAGE_SIZE
        except Exception:
            return False

    def _get_file_hash(self, filepath: Path) -> str:
        """Calculate SHA-256 hash of a file"""
        sha256_hash = hashlib.sha256()
        with open(filepath, "rb") as f:
            for byte_block in iter(lambda: f.read(4096), b""):
                sha256_hash.update(byte_block)
        return sha256_hash.hexdigest()

    def _check_repo_availability(self, repo_url: str) -> bool:
        """Check if repository is accessible"""
        try:
            parsed_url = urlparse(repo_url)
            api_url = f"https://api.github.com/repos{parsed_url.path}"
            response = requests.head(api_url, timeout=TIMEOUT)
            return response.status_code == 200
        except Exception:
            return False

    def _clone_with_retry(self, repo_url: str, repo_path: Path) -> bool:
        """Clone repository with retry mechanism"""
        for attempt in range(MAX_RETRIES):
            try:
                if attempt > 0:
                    time.sleep(2 ** attempt)  # Exponential backoff
                subprocess.run(
                    ['git', 'clone', '--depth', '1', repo_url, str(repo_path)],
                    check=True, capture_output=True, timeout=TIMEOUT
                )
                return True
            except subprocess.SubprocessError:
                if attempt == MAX_RETRIES - 1:
                    return False
        return False

    def process_repository(self, repo_url: str) -> int:
        """Process a single repository and collect its wallpapers"""
        repo_name = repo_url.split('/')[-1].replace('.git', '')
        repo_path = self.temp_dir / repo_name
        wallpapers_count = 0

        if not self._check_repo_availability(repo_url):
            return 0

        if not self._clone_with_retry(repo_url, repo_path):
            return 0

        try:
            image_files = []
            for ext in IMAGE_FORMATS:
                image_files.extend(repo_path.glob(f"**/*{ext}"))
                image_files.extend(repo_path.glob(f"**/*{ext.upper()}"))

            for image_file in image_files:
                try:
                    if not self._validate_image(image_file):
                        continue

                    file_hash = self._get_file_hash(image_file)
                    if file_hash in self.processed_hashes:
                        continue

                    new_name = f"{repo_name}_{image_file.name}"
                    destination = self.output_folder / new_name
                    shutil.copy2(image_file, destination)
                    self.processed_hashes.add(file_hash)
                    wallpapers_count += 1

                except Exception:
                    continue

            self.successful_repos += 1
            return wallpapers_count

        except Exception:
            return wallpapers_count
        finally:
            shutil.rmtree(repo_path, ignore_errors=True)

    def run(self):
        """Main execution method"""
        print("\n╔═══════════════════════════════════════╗")
        print("║           WallPimp v2.0               ║")
        print("╚═══════════════════════════════════════╝\n")

        # Create necessary directories
        self.output_folder.mkdir(parents=True, exist_ok=True)
        self.temp_dir.mkdir(exist_ok=True)

        try:
            with ThreadPoolExecutor(max_workers=3) as executor:
                futures = [
                    executor.submit(self.process_repository, repo_url)
                    for repo_url in WALLPAPER_REPOS
                ]
                
                with tqdm(total=len(WALLPAPER_REPOS), 
                         desc="Collecting wallpapers", 
                         bar_format='{desc}: {percentage:3.0f}%|{bar}| {n_fmt}/{total_fmt}') as pbar:
                    for future in as_completed(futures):
                        self.total_wallpapers += future.result()
                        pbar.update(1)

        finally:
            shutil.rmtree(self.temp_dir, ignore_errors=True)

        print(f"\n✨ Collection complete! Downloaded {self.total_wallpapers} wallpapers")
        print(f"📁 Saved to: {self.output_folder}")
        if self.successful_repos < len(WALLPAPER_REPOS):
            print(f"⚠️  Note: {len(WALLPAPER_REPOS) - self.successful_repos} repositories were skipped due to access issues")

def main():
    """Entry point of the script"""
    try:
        # Check for git installation
        subprocess.run(['git', '--version'], 
                      check=True, 
                      capture_output=True, 
                      timeout=5)
    except Exception:
        print("Error: Git is not installed. Please install Git and try again.")
        sys.exit(1)

    wallpimp = WallPimp()
    wallpimp.run()

if __name__ == "__main__":
    main()
