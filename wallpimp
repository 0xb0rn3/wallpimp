#!/usr/bin/env python3

import os
import sys
import json
import subprocess
import shutil
import random
import zipfile
import tempfile
import time
import signal
import hashlib
import threading
from pathlib import Path
from urllib.parse import urlparse
from concurrent.futures import ThreadPoolExecutor, as_completed

DEPS = {'requests': 'requests', 'tqdm': 'tqdm'}

def install_deps():
    missing = []
    for module, spec in DEPS.items():
        try:
            __import__(module)
        except ImportError:
            missing.append(spec)
    
    if missing:
        print("Installing dependencies...")
        for dep in missing:
            for flag in ['--break-system-packages', '']:
                try:
                    cmd = [sys.executable, '-m', 'pip', 'install'] + ([flag] if flag else []) + [dep]
                    subprocess.check_call(cmd, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
                    break
                except:
                    continue

install_deps()

import requests
from tqdm import tqdm

class Loader:
    def __init__(self, message="Processing"):
        self.message = message
        self.running = False
        self.thread = None
    
    def _animate(self):
        chars = "⠋⠙⠹⠸⠼⠴⠦⠧⠇⠏"
        idx = 0
        while self.running:
            sys.stdout.write(f'\r{self.message} {chars[idx % len(chars)]}')
            sys.stdout.flush()
            idx += 1
            time.sleep(0.1)
        sys.stdout.write('\r' + ' ' * (len(self.message) + 2) + '\r')
        sys.stdout.flush()
    
    def start(self):
        self.running = True
        self.thread = threading.Thread(target=self._animate, daemon=True)
        self.thread.start()
    
    def stop(self):
        self.running = False
        if self.thread:
            self.thread.join()

class Config:
    def __init__(self):
        self.config_dir = Path.home() / '.config' / 'wallpimp'
        self.config_file = self.config_dir / 'config.json'
        self.hash_db_file = self.config_dir / 'hashes.json'
        self.config_dir.mkdir(parents=True, exist_ok=True)
        self.load()
        self.hash_db = self._load_hash_db()
    
    def load(self):
        defaults = {
            'wallpaper_dir': str(Path.home() / 'Pictures' / 'Wallpapers'),
            'slideshow_interval': 300,
            'download_workers': 8,
        }
        
        if self.config_file.exists():
            try:
                with open(self.config_file, 'r') as f:
                    self.data = {**defaults, **json.load(f)}
            except:
                self.data = defaults
        else:
            self.data = defaults
        
        Path(self.data['wallpaper_dir']).mkdir(parents=True, exist_ok=True)
    
    def save(self):
        with open(self.config_file, 'w') as f:
            json.dump(self.data, f, indent=2)
    
    def get(self, key, default=None):
        return self.data.get(key, default)
    
    def set(self, key, value):
        self.data[key] = value
        self.save()
    
    def _load_hash_db(self):
        if self.hash_db_file.exists():
            try:
                with open(self.hash_db_file, 'r') as f:
                    return json.load(f)
            except:
                return {}
        return {}
    
    def _save_hash_db(self):
        with open(self.hash_db_file, 'w') as f:
            json.dump(self.hash_db, f, indent=2)
    
    def add_hash(self, file_hash, file_path):
        self.hash_db[file_hash] = str(file_path)
        self._save_hash_db()
    
    def hash_exists(self, file_hash):
        return file_hash in self.hash_db
    
    def get_hash_path(self, file_hash):
        return self.hash_db.get(file_hash)
    
    def cleanup_missing_hashes(self):
        cleaned = 0
        to_remove = []
        
        for file_hash, file_path in self.hash_db.items():
            if not Path(file_path).exists():
                to_remove.append(file_hash)
                cleaned += 1
        
        for file_hash in to_remove:
            del self.hash_db[file_hash]
        
        if cleaned > 0:
            self._save_hash_db()
        
        return cleaned

class SystemDetector:
    @staticmethod
    def detect_de():
        de_vars = ['DESKTOP_SESSION', 'XDG_CURRENT_DESKTOP', 'GDMSESSION']
        
        for var in de_vars:
            value = os.environ.get(var, '').lower()
            if 'xfce' in value:
                return 'xfce'
            elif 'gnome' in value:
                return 'gnome'
        
        try:
            processes = subprocess.check_output(['ps', 'aux'], universal_newlines=True)
            if 'xfce' in processes.lower():
                return 'xfce'
            elif 'gnome' in processes.lower():
                return 'gnome'
        except:
            pass
        
        return 'unknown'

def calculate_file_hash(file_path):
    hash_md5 = hashlib.md5()
    try:
        with open(file_path, 'rb') as f:
            for chunk in iter(lambda: f.read(4096), b""):
                hash_md5.update(chunk)
        return hash_md5.hexdigest()
    except:
        return None

class RepoManager:
    REPOS = {
        'minimalist': {
            'url': 'https://github.com/dharmx/walls',
            'branch': 'main',
        },
        'anime': {
            'url': 'https://github.com/HENTAI-CODER/Anime-Wallpaper',
            'branch': 'main',
        },
        'nature': {
            'url': 'https://github.com/FrenzyExists/wallpapers',
            'branch': 'main',
        },
        'scenic': {
            'url': 'https://github.com/michaelScopic/Wallpapers',
            'branch': 'main',
        },
        'artistic': {
            'url': 'https://github.com/D3Ext/aesthetic-wallpapers',
            'branch': 'main',
        }
    }
    
    def __init__(self, config):
        self.config = config
    
    def _validate_repo_url(self, url):
        try:
            if 'github.com' not in url:
                return False
            
            parsed = urlparse(url)
            path_parts = parsed.path.strip('/').split('/')
            if len(path_parts) < 2:
                return False
            
            owner, repo = path_parts[0], path_parts[1]
            
            check_url = f"https://api.github.com/repos/{owner}/{repo}"
            resp = requests.head(check_url, timeout=5)
            return resp.status_code == 200
        except:
            return False
    
    def _extract_repo_info(self, url):
        parsed = urlparse(url)
        path_parts = parsed.path.strip('/').split('/')
        owner = path_parts[0]
        repo = path_parts[1].replace('.git', '')
        return owner, repo
    
    def download_via_archive(self, url, branch, dest_dir):
        try:
            owner, repo = self._extract_repo_info(url)
            archive_url = f"https://github.com/{owner}/{repo}/archive/{branch}.zip"
            
            print(f"Downloading {repo}...")
            
            resp = requests.get(archive_url, stream=True, timeout=30)
            if resp.status_code == 404:
                print(f"Error: Repo faulty or non-existent. Please verify the repository exists.")
                return False
            
            resp.raise_for_status()
            
            total_size = int(resp.headers.get('content-length', 0))
            
            with tempfile.NamedTemporaryFile(delete=False, suffix='.zip') as tmp_file:
                tmp_path = tmp_file.name
                
                with tqdm(total=total_size, unit='B', unit_scale=True, desc=repo) as pbar:
                    for chunk in resp.iter_content(chunk_size=8192):
                        tmp_file.write(chunk)
                        pbar.update(len(chunk))
            
            print(f"Extracting {repo}...")
            extracted = 0
            duplicates = 0
            
            with zipfile.ZipFile(tmp_path, 'r') as zip_ref:
                members = zip_ref.namelist()
                root_dir = members[0].split('/')[0] if members else None
                
                image_members = [m for m in members if m.lower().endswith(('.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp'))]
                
                with tqdm(total=len(image_members), desc="Processing", unit="img") as pbar:
                    for member in image_members:
                        member_path = member
                        if root_dir and member.startswith(root_dir + '/'):
                            member_path = member[len(root_dir) + 1:]
                        
                        if not member_path:
                            pbar.update(1)
                            continue
                        
                        target_path = dest_dir / member_path
                        
                        with zip_ref.open(member) as source:
                            temp_file = tempfile.NamedTemporaryFile(delete=False)
                            temp_file.write(source.read())
                            temp_file.close()
                            
                            file_hash = calculate_file_hash(temp_file.name)
                            
                            if file_hash and self.config.hash_exists(file_hash):
                                os.unlink(temp_file.name)
                                duplicates += 1
                            else:
                                target_path.parent.mkdir(parents=True, exist_ok=True)
                                shutil.move(temp_file.name, target_path)
                                if file_hash:
                                    self.config.add_hash(file_hash, target_path)
                                extracted += 1
                        
                        pbar.update(1)
            
            os.unlink(tmp_path)
            print(f"✓ {repo}: {extracted} new, {duplicates} duplicates skipped")
            return True
            
        except requests.exceptions.RequestException as e:
            print(f"Error: Network issue - {e}")
            return False
        except zipfile.BadZipFile:
            print(f"Error: Downloaded file is corrupted")
            return False
        except Exception as e:
            print(f"Error: {e}")
            return False
    
    def download_via_git(self, url, dest_dir):
        try:
            _, repo = self._extract_repo_info(url)
            
            temp_dir = tempfile.mkdtemp()
            
            print(f"Cloning {repo} via git...")
            
            subprocess.run(
                ['git', 'clone', '--depth', '1', '--quiet', url, temp_dir],
                check=True,
                stderr=subprocess.PIPE
            )
            
            shutil.rmtree(Path(temp_dir) / '.git', ignore_errors=True)
            
            loader = Loader("Scanning for images")
            loader.start()
            
            images = []
            for ext in ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp']:
                images.extend(Path(temp_dir).rglob(f'*{ext}'))
            
            loader.stop()
            
            extracted = 0
            duplicates = 0
            
            print(f"Processing {len(images)} images...")
            
            with tqdm(total=len(images), desc="Processing", unit="img") as pbar:
                for img_path in images:
                    file_hash = calculate_file_hash(img_path)
                    
                    if file_hash and self.config.hash_exists(file_hash):
                        duplicates += 1
                    else:
                        rel_path = img_path.relative_to(temp_dir)
                        target_path = dest_dir / rel_path
                        target_path.parent.mkdir(parents=True, exist_ok=True)
                        shutil.copy2(img_path, target_path)
                        if file_hash:
                            self.config.add_hash(file_hash, target_path)
                        extracted += 1
                    
                    pbar.update(1)
            
            shutil.rmtree(temp_dir, ignore_errors=True)
            
            print(f"✓ {repo}: {extracted} new, {duplicates} duplicates skipped")
            return True
            
        except subprocess.CalledProcessError as e:
            if b'not found' in e.stderr or b'does not exist' in e.stderr:
                print(f"Error: Repo faulty or non-existent. Please verify the repository exists.")
            else:
                print(f"Error: Git clone failed - {e.stderr.decode()}")
            return False
        except Exception as e:
            print(f"Error: {e}")
            return False
    
    def download_repo(self, repo_name):
        if repo_name not in self.REPOS:
            print(f"Error: Unknown repository '{repo_name}'")
            return False
        
        repo_info = self.REPOS[repo_name]
        url = repo_info['url']
        branch = repo_info['branch']
        
        dest_dir = Path(self.config.get('wallpaper_dir')) / repo_name
        
        if not self._validate_repo_url(url):
            print(f"Error: Repo faulty or non-existent. Please verify {url} exists.")
            return False
        
        if shutil.which('git'):
            success = self.download_via_git(url, dest_dir)
        else:
            success = self.download_via_archive(url, branch, dest_dir)
        
        if not success and shutil.which('git'):
            print("Retrying with archive method...")
            success = self.download_via_archive(url, branch, dest_dir)
        
        return success
    
    def download_custom(self, url):
        if not self._validate_repo_url(url):
            print(f"Error: Repo faulty or non-existent. Please verify {url} exists.")
            return False
        
        owner, repo = self._extract_repo_info(url)
        dest_dir = Path(self.config.get('wallpaper_dir')) / repo
        
        if shutil.which('git'):
            return self.download_via_git(url, dest_dir)
        else:
            return self.download_via_archive(url, 'main', dest_dir)

class SlideshowDaemon:
    def __init__(self, config, de):
        self.config = config
        self.de = de
        self.running = True
        signal.signal(signal.SIGINT, self._signal_handler)
        signal.signal(signal.SIGTERM, self._signal_handler)
    
    def _signal_handler(self, signum, frame):
        self.running = False
    
    def _get_wallpapers(self):
        wallpaper_dir = Path(self.config.get('wallpaper_dir'))
        images = []
        
        for ext in ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp']:
            images.extend(wallpaper_dir.rglob(f'*{ext}'))
        
        return images
    
    def _set_xfce_wallpaper(self, path):
        try:
            result = subprocess.run(
                ['xfconf-query', '-c', 'xfce4-desktop', '-l'],
                capture_output=True, text=True, check=True
            )
            properties = [line for line in result.stdout.split('\n') if 'last-image' in line]
            
            for prop in properties:
                subprocess.run(
                    ['xfconf-query', '-c', 'xfce4-desktop', '-p', prop, '-s', str(path)],
                    stderr=subprocess.DEVNULL
                )
        except:
            pass
    
    def _set_gnome_wallpaper(self, path):
        try:
            subprocess.run(
                ['gsettings', 'set', 'org.gnome.desktop.background', 'picture-uri', f'file://{path}'],
                stderr=subprocess.DEVNULL
            )
            subprocess.run(
                ['gsettings', 'set', 'org.gnome.desktop.background', 'picture-uri-dark', f'file://{path}'],
                stderr=subprocess.DEVNULL
            )
        except:
            pass
    
    def set_wallpaper(self, path):
        if self.de == 'xfce':
            self._set_xfce_wallpaper(path)
        elif self.de == 'gnome':
            self._set_gnome_wallpaper(path)
    
    def run(self):
        images = self._get_wallpapers()
        
        if not images:
            print(f"Error: No wallpapers found in {self.config.get('wallpaper_dir')}")
            return 1
        
        print(f"WallPimp Slideshow Started")
        print(f"Found {len(images)} wallpapers")
        print(f"Interval: {self.config.get('slideshow_interval')}s")
        print(f"Desktop: {self.de}")
        
        interval = self.config.get('slideshow_interval', 300)
        
        while self.running:
            wallpaper = random.choice(images)
            self.set_wallpaper(str(wallpaper))
            print(f"Set: {wallpaper.name}")
            
            for _ in range(interval):
                if not self.running:
                    break
                time.sleep(1)
        
        print("Slideshow stopped")
        return 0

class WallpaperManager:
    def __init__(self):
        self.config = Config()
        self.de = SystemDetector.detect_de()
        self.repo_manager = RepoManager(self.config)
    
    def main_menu(self):
        while True:
            print("\n=== WallPimp ===")
            print("1. Download wallpapers")
            print("2. Settings")
            print("3. Slideshow control")
            print("4. Set random wallpaper")
            print("5. Exit")
            
            choice = input("\nSelect: ").strip()
            
            if choice == '1':
                self.download_menu()
            elif choice == '2':
                self.settings_menu()
            elif choice == '3':
                self.slideshow_menu()
            elif choice == '4':
                self.set_random_wallpaper()
            elif choice == '5':
                break
    
    def download_menu(self):
        while True:
            print("\n=== Downloads ===")
            print("1. List repositories")
            print("2. Download repository")
            print("3. Download all")
            print("4. Download custom URL")
            print("5. Back")
            
            choice = input("\nSelect: ").strip()
            
            if choice == '1':
                print("\nAvailable repositories:")
                for name in self.repo_manager.REPOS.keys():
                    print(f"  - {name}")
            elif choice == '2':
                repo = input("Repository name: ").strip()
                self.repo_manager.download_repo(repo)
            elif choice == '3':
                for repo_name in self.repo_manager.REPOS.keys():
                    self.repo_manager.download_repo(repo_name)
            elif choice == '4':
                url = input("GitHub URL: ").strip()
                if url:
                    self.repo_manager.download_custom(url)
            elif choice == '5':
                break
    
    def settings_menu(self):
        while True:
            print("\n=== Settings ===")
            print("1. Change wallpaper directory")
            print("2. Set slideshow interval")
            print("3. Set download workers")
            print("4. View settings")
            print("5. Cleanup hash database")
            print("6. Back")
            
            choice = input("\nSelect: ").strip()
            
            if choice == '1':
                new_dir = input(f"Current: {self.config.get('wallpaper_dir')}\nNew: ").strip()
                if new_dir:
                    path = Path(new_dir).expanduser()
                    path.mkdir(parents=True, exist_ok=True)
                    self.config.set('wallpaper_dir', str(path))
                    print(f"Updated to: {path}")
            elif choice == '2':
                interval = input(f"Current: {self.config.get('slideshow_interval')}s\nNew (seconds): ").strip()
                if interval.isdigit():
                    self.config.set('slideshow_interval', int(interval))
                    print("Updated")
            elif choice == '3':
                workers = input(f"Current: {self.config.get('download_workers')}\nNew (1-32): ").strip()
                if workers.isdigit() and 1 <= int(workers) <= 32:
                    self.config.set('download_workers', int(workers))
                    print("Updated")
            elif choice == '4':
                print(f"\nWallpaper Dir: {self.config.get('wallpaper_dir')}")
                print(f"Interval: {self.config.get('slideshow_interval')}s")
                print(f"Workers: {self.config.get('download_workers')}")
                print(f"Tracked Hashes: {len(self.config.hash_db)}")
            elif choice == '5':
                loader = Loader("Cleaning hash database")
                loader.start()
                cleaned = self.config.cleanup_missing_hashes()
                loader.stop()
                print(f"Removed {cleaned} orphaned hashes")
            elif choice == '6':
                break
    
    def slideshow_menu(self):
        if self.de not in ['xfce', 'gnome']:
            print(f"\nError: Slideshow only supports XFCE and GNOME")
            print(f"Detected: {self.de}")
            return
        
        while True:
            print("\n=== Slideshow ===")
            print("1. Start slideshow")
            print("2. Stop slideshow")
            print("3. Enable autostart")
            print("4. Disable autostart")
            print("5. Check status")
            print("6. Run slideshow now (foreground)")
            print("7. Back")
            
            choice = input("\nSelect: ").strip()
            
            if choice == '1':
                self._start_slideshow_service()
            elif choice == '2':
                self._stop_slideshow_service()
            elif choice == '3':
                self._enable_autostart()
            elif choice == '4':
                self._disable_autostart()
            elif choice == '5':
                self._check_status()
            elif choice == '6':
                daemon = SlideshowDaemon(self.config, self.de)
                daemon.run()
            elif choice == '7':
                break
    
    def _install_service(self):
        service_dir = Path.home() / '.config' / 'systemd' / 'user'
        service_dir.mkdir(parents=True, exist_ok=True)
        
        wallpimp_path = Path(__file__).resolve()
        
        service_content = f"""[Unit]
Description=WallPimp Slideshow
After=graphical-session.target

[Service]
Type=simple
ExecStart={sys.executable} {wallpimp_path} --daemon
Restart=always
RestartSec=10

[Install]
WantedBy=default.target
"""
        
        timer_content = """[Unit]
Description=WallPimp Slideshow Timer
After=graphical-session.target

[Timer]
OnBootSec=30
OnUnitActiveSec=60
Persistent=true

[Install]
WantedBy=timers.target
"""
        
        (service_dir / 'wallpimp-slideshow.service').write_text(service_content)
        (service_dir / 'wallpimp-slideshow.timer').write_text(timer_content)
        
        subprocess.run(['systemctl', '--user', 'daemon-reload'], stderr=subprocess.DEVNULL)
    
    def _start_slideshow_service(self):
        self._install_service()
        try:
            subprocess.run(['systemctl', '--user', 'start', 'wallpimp-slideshow.service'], check=True)
            print("Slideshow started")
        except:
            print("Failed to start slideshow")
    
    def _stop_slideshow_service(self):
        try:
            subprocess.run(['systemctl', '--user', 'stop', 'wallpimp-slideshow.service'], check=True)
            print("Slideshow stopped")
        except:
            print("Failed to stop slideshow")
    
    def _enable_autostart(self):
        self._install_service()
        try:
            subprocess.run(['systemctl', '--user', 'enable', 'wallpimp-slideshow.service'], check=True)
            print("Autostart enabled")
        except:
            print("Failed to enable autostart")
    
    def _disable_autostart(self):
        try:
            subprocess.run(['systemctl', '--user', 'disable', 'wallpimp-slideshow.service'], check=True)
            print("Autostart disabled")
        except:
            print("Failed to disable autostart")
    
    def _check_status(self):
        try:
            subprocess.run(['systemctl', '--user', 'status', 'wallpimp-slideshow.service'])
        except:
            print("Service not found")
    
    def set_random_wallpaper(self):
        wallpaper_dir = Path(self.config.get('wallpaper_dir'))
        images = []
        
        for ext in ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp']:
            images.extend(wallpaper_dir.rglob(f'*{ext}'))
        
        if not images:
            print(f"No wallpapers found in {wallpaper_dir}")
            return
        
        selected = random.choice(images)
        
        if self.de == 'xfce':
            self._set_xfce(str(selected))
        elif self.de == 'gnome':
            self._set_gnome(str(selected))
        else:
            print(f"Unsupported DE: {self.de}")
            return
        
        print(f"Set: {selected.name}")
    
    def _set_xfce(self, path):
        try:
            result = subprocess.run(['xfconf-query', '-c', 'xfce4-desktop', '-l'],
                                  capture_output=True, text=True)
            properties = [line for line in result.stdout.split('\n') if 'last-image' in line]
            for prop in properties:
                subprocess.run(['xfconf-query', '-c', 'xfce4-desktop', '-p', prop, '-s', path],
                             stderr=subprocess.DEVNULL)
        except:
            pass
    
    def _set_gnome(self, path):
        try:
            subprocess.run(['gsettings', 'set', 'org.gnome.desktop.background',
                          'picture-uri', f'file://{path}'], stderr=subprocess.DEVNULL)
            subprocess.run(['gsettings', 'set', 'org.gnome.desktop.background',
                          'picture-uri-dark', f'file://{path}'], stderr=subprocess.DEVNULL)
        except:
            pass

def main():
    if len(sys.argv) > 1 and sys.argv[1] == '--daemon':
        config = Config()
        de = SystemDetector.detect_de()
        daemon = SlideshowDaemon(config, de)
        sys.exit(daemon.run())
    else:
        manager = WallpaperManager()
        manager.main_menu()

if __name__ == '__main__':
    main()
