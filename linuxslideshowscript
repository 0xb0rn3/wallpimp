#!/usr/bin/env bash
# Universal Wallpaper Slideshow Script
# Compatible with ALL major desktop environments and operating systems
# Features: Robust error handling, dependency checking, multi-monitor support

set -euo pipefail  # Enable strict error handling

# Configuration section - these can be customized
INTERVAL=300  # Time between wallpaper changes in seconds (300 = 5 minutes)
RANDOM_ORDER=true  # Set to false for alphabetical order
LOG_FILE="$HOME/.wallpaper_slideshow.log"
PID_FILE="$HOME/.wallpaper_slideshow.pid"
SCRIPT_NAME="$(basename "$0")"
SCRIPT_PATH="$(readlink -f "$0")"

# Desktop file for autostart functionality
DESKTOP_FILE="$HOME/.config/autostart/wallpaper-slideshow.desktop"

# Color codes for better output formatting
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to print colored output
print_colored() {
    local color="$1"
    local message="$2"
    echo -e "${color}${message}${NC}"
}

# Function to log messages with timestamps
log_message() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1" >> "$LOG_FILE"
}

# Function to safely get user input and clean it
get_wallpaper_directory() {
    local dir=""
    while true; do
        echo -n "Enter the directory containing your wallpapers: "
        read -r dir
        
        # Remove surrounding quotes if present
        dir=$(echo "$dir" | sed 's/^["'\'']*//;s/["'\'']*$//')
        
        # Expand tilde to home directory
        dir="${dir/#\~/$HOME}"
        
        # Convert to absolute path
        dir=$(realpath "$dir" 2>/dev/null || echo "$dir")
        
        if [[ -d "$dir" ]]; then
            echo "$dir"
            return 0
        else
            print_colored "$RED" "Error: Directory '$dir' does not exist. Please try again."
        fi
    done
}

# Enhanced function to detect operating system
detect_os() {
    if [[ "$OSTYPE" == "linux-gnu"* ]]; then
        echo "linux"
    elif [[ "$OSTYPE" == "darwin"* ]]; then
        echo "macos"
    elif [[ "$OSTYPE" == "cygwin" ]] || [[ "$OSTYPE" == "msys" ]] || [[ "$OSTYPE" == "win32" ]]; then
        echo "windows"
    elif [[ "$OSTYPE" == "freebsd"* ]] || [[ "$OSTYPE" == "openbsd"* ]] || [[ "$OSTYPE" == "netbsd"* ]]; then
        echo "bsd"
    else
        echo "unknown"
    fi
}

# Enhanced desktop environment detection with better fallbacks
detect_desktop_environment() {
    local os_type=$(detect_os)
    
    # macOS handling
    if [[ "$os_type" == "macos" ]]; then
        echo "macos"
        return 0
    fi
    
    # Windows handling (WSL or native)
    if [[ "$os_type" == "windows" ]]; then
        echo "windows"
        return 0
    fi
    
    # Linux/BSD desktop environment detection
    # Check XDG_CURRENT_DESKTOP first (most reliable)
    if [[ -n "${XDG_CURRENT_DESKTOP:-}" ]]; then
        case "${XDG_CURRENT_DESKTOP,,}" in
            *xfce*) echo "xfce" && return 0 ;;
            *gnome*) echo "gnome" && return 0 ;;
            *kde*|*plasma*) echo "kde" && return 0 ;;
            *mate*) echo "mate" && return 0 ;;
            *cinnamon*) echo "cinnamon" && return 0 ;;
            *lxde*|*lxqt*) echo "lxde" && return 0 ;;
            *unity*) echo "unity" && return 0 ;;
            *budgie*) echo "budgie" && return 0 ;;
            *pantheon*) echo "pantheon" && return 0 ;;
            *i3*) echo "i3" && return 0 ;;
            *sway*) echo "sway" && return 0 ;;
        esac
    fi
    
    # Check DESKTOP_SESSION as fallback
    if [[ -n "${DESKTOP_SESSION:-}" ]]; then
        case "${DESKTOP_SESSION,,}" in
            *xfce*) echo "xfce" && return 0 ;;
            *gnome*) echo "gnome" && return 0 ;;
            *kde*|*plasma*) echo "kde" && return 0 ;;
            *mate*) echo "mate" && return 0 ;;
            *cinnamon*) echo "cinnamon" && return 0 ;;
            *openbox*) echo "openbox" && return 0 ;;
            *i3*) echo "i3" && return 0 ;;
        esac
    fi
    
    # Process-based detection for window managers
    local wm_processes=("i3" "openbox" "awesome" "bspwm" "dwm" "sway" "hyprland" "qtile" "xmonad")
    for wm in "${wm_processes[@]}"; do
        if pgrep -x "$wm" > /dev/null 2>&1; then
            echo "$wm"
            return 0
        fi
    done
    
    # Command-based detection with better testing
    if command -v xfconf-query > /dev/null && xfconf-query -c xfce4-desktop -l > /dev/null 2>&1; then
        echo "xfce"
    elif command -v gsettings > /dev/null && gsettings list-schemas 2>/dev/null | grep -q "org.gnome.desktop.background"; then
        echo "gnome"
    elif command -v kwriteconfig5 > /dev/null || command -v kwriteconfig > /dev/null || command -v plasma-apply-wallpaperimage > /dev/null; then
        echo "kde"
    elif command -v dconf > /dev/null && dconf list /org/mate/desktop/background/ > /dev/null 2>&1; then
        echo "mate"
    elif command -v dconf > /dev/null && dconf list /org/cinnamon/desktop/background/ > /dev/null 2>&1; then
        echo "cinnamon"
    elif command -v feh > /dev/null; then
        echo "generic_feh"
    elif command -v nitrogen > /dev/null; then
        echo "generic_nitrogen"
    elif command -v hsetroot > /dev/null; then
        echo "generic_hsetroot"
    elif command -v xsetroot > /dev/null; then
        echo "generic_xsetroot"
    else
        echo "unknown"
    fi
}

# Function to check and install dependencies
check_dependencies() {
    local desktop_env="$1"
    local missing_deps=()
    
    case "$desktop_env" in
        "xfce")
            command -v xfconf-query > /dev/null || missing_deps+=("xfconf")
            ;;
        "gnome"|"unity"|"pantheon"|"budgie")
            command -v gsettings > /dev/null || missing_deps+=("gsettings")
            ;;
        "kde")
            if ! (command -v qdbus > /dev/null || command -v plasma-apply-wallpaperimage > /dev/null); then
                missing_deps+=("kde-cli-tools or plasma-workspace")
            fi
            ;;
        "mate")
            command -v dconf > /dev/null || missing_deps+=("dconf-cli")
            ;;
        "cinnamon")
            command -v dconf > /dev/null || missing_deps+=("dconf-cli")
            ;;
        "sway"|"hyprland")
            command -v swaybg > /dev/null || missing_deps+=("swaybg")
            ;;
        "openbox"|"i3"|"awesome"|"bspwm"|"dwm"|"lxde"|"generic_feh")
            if ! command -v feh > /dev/null; then
                if command -v nitrogen > /dev/null; then
                    desktop_env="generic_nitrogen"
                elif command -v hsetroot > /dev/null; then
                    desktop_env="generic_hsetroot"
                else
                    missing_deps+=("feh or nitrogen or hsetroot")
                fi
            fi
            ;;
        "generic_nitrogen")
            command -v nitrogen > /dev/null || missing_deps+=("nitrogen")
            ;;
        "macos")
            # macOS uses built-in osascript, no additional dependencies needed
            ;;
    esac
    
    if [[ ${#missing_deps[@]} -gt 0 ]]; then
        print_colored "$RED" "Missing dependencies: ${missing_deps[*]}"
        print_colored "$YELLOW" "Please install the missing packages and try again."
        return 1
    fi
    
    echo "$desktop_env"  # Return the potentially modified desktop environment
    return 0
}

# Function to get all monitors (for multi-monitor support)
get_monitors() {
    local monitors=()
    
    if command -v xrandr > /dev/null 2>&1; then
        # X11 systems
        while IFS= read -r line; do
            if [[ $line =~ ^([A-Za-z0-9-]+)\ connected ]]; then
                monitors+=("${BASH_REMATCH[1]}")
            fi
        done < <(xrandr --query 2>/dev/null)
    elif command -v wlr-randr > /dev/null 2>&1; then
        # Wayland systems with wlr-randr
        while IFS= read -r line; do
            if [[ $line =~ ^([A-Za-z0-9-]+)\ \".*\"\ \(connected\) ]]; then
                monitors+=("${BASH_REMATCH[1]}")
            fi
        done < <(wlr-randr 2>/dev/null)
    fi
    
    # If no monitors detected, use default
    if [[ ${#monitors[@]} -eq 0 ]]; then
        monitors=("default")
    fi
    
    printf '%s\n' "${monitors[@]}"
}

# macOS wallpaper setting function
set_wallpaper_macos() {
    local wallpaper_path="$1"
    
    # Convert to absolute path for macOS
    wallpaper_path=$(realpath "$wallpaper_path")
    
    # Set wallpaper using AppleScript
    osascript -e "tell application \"Finder\" to set desktop picture to POSIX file \"$wallpaper_path\"" 2>/dev/null
    
    log_message "macOS: Set wallpaper to $wallpaper_path"
}

# XFCE wallpaper setting with improved multi-monitor support
set_wallpaper_xfce() {
    local wallpaper_path="$1"
    
    # Get all backdrop properties for all monitors and workspaces
    local backdrop_props
    backdrop_props=$(xfconf-query -c xfce4-desktop -l 2>/dev/null | grep -E "backdrop.*image-path$|backdrop.*last-image$" || true)
    
    if [[ -z "$backdrop_props" ]]; then
        # Generate comprehensive fallback properties for common configurations
        local monitors screens workspaces
        monitors=($(get_monitors))
        screens=(0 1)  # Most systems have 0-1 screens
        workspaces=(0 1 2 3)  # Cover first 4 workspaces
        
        for screen in "${screens[@]}"; do
            for monitor in "${monitors[@]}"; do
                for workspace in "${workspaces[@]}"; do
                    # Try different monitor naming conventions
                    local monitor_variants=("$monitor" "${monitor//-/}" "monitor${monitor}" "monitor${monitor^^}")
                    for variant in "${monitor_variants[@]}"; do
                        local props=(
                            "/backdrop/screen${screen}/monitor${variant}/workspace${workspace}/last-image"
                            "/backdrop/screen${screen}/monitor${variant}/workspace${workspace}/image-path"
                            "/backdrop/screen${screen}/monitor${variant}/image-path"
                        )
                        for prop in "${props[@]}"; do
                            xfconf-query -c xfce4-desktop -p "$prop" -s "$wallpaper_path" 2>/dev/null || true
                        done
                    done
                done
            done
        done
    else
        # Set wallpaper for all detected backdrop properties
        while IFS= read -r prop; do
            [[ -n "$prop" ]] && xfconf-query -c xfce4-desktop -p "$prop" -s "$wallpaper_path" 2>/dev/null || true
        done <<< "$backdrop_props"
    fi
    
    log_message "XFCE: Set wallpaper to $wallpaper_path"
}

# GNOME wallpaper setting with better error handling
set_wallpaper_gnome() {
    local wallpaper_path="$1"
    local file_uri="file://$wallpaper_path"
    
    # Set wallpaper using gsettings with proper error handling
    if gsettings set org.gnome.desktop.background picture-uri "$file_uri" 2>/dev/null; then
        gsettings set org.gnome.desktop.background picture-uri-dark "$file_uri" 2>/dev/null || true
        gsettings set org.gnome.desktop.background picture-options 'scaled' 2>/dev/null || true
        log_message "GNOME: Set wallpaper to $wallpaper_path"
        return 0
    else
        log_message "ERROR: Failed to set GNOME wallpaper"
        return 1
    fi
}

# KDE wallpaper setting with multiple methods
set_wallpaper_kde() {
    local wallpaper_path="$1"
    local success=false
    
    # Method 1: plasma-apply-wallpaperimage (newer KDE)
    if command -v plasma-apply-wallpaperimage > /dev/null; then
        if plasma-apply-wallpaperimage "$wallpaper_path" 2>/dev/null; then
            success=true
        fi
    fi
    
    # Method 2: qdbus (traditional method)
    if [[ "$success" == false ]] && command -v qdbus > /dev/null; then
        local script="
            var allDesktops = desktops();
            for (i=0; i<allDesktops.length; i++) {
                d = allDesktops[i];
                d.wallpaperPlugin = 'org.kde.image';
                d.currentConfigGroup = Array('Wallpaper', 'org.kde.image', 'General');
                d.writeConfig('Image', 'file://$wallpaper_path');
            }"
        
        if qdbus org.kde.plasmashell /PlasmaShell org.kde.PlasmaShell.evaluateScript "$script" 2>/dev/null; then
            success=true
        fi
    fi
    
    # Method 3: kwriteconfig (fallback)
    if [[ "$success" == false ]]; then
        if command -v kwriteconfig5 > /dev/null; then
            kwriteconfig5 --file ~/.config/plasma-org.kde.plasma.desktop-appletsrc --group "Containments" --group "1" --group "Wallpaper" --group "org.kde.image" --group "General" --key "Image" "file://$wallpaper_path" 2>/dev/null || true
            success=true
        elif command -v kwriteconfig > /dev/null; then
            kwriteconfig --file ~/.config/plasma-org.kde.plasma.desktop-appletsrc --group "Containments" --group "1" --group "Wallpaper" --group "org.kde.image" --group "General" --key "Image" "file://$wallpaper_path" 2>/dev/null || true
            success=true
        fi
    fi
    
    if [[ "$success" == true ]]; then
        log_message "KDE: Set wallpaper to $wallpaper_path"
        return 0
    else
        log_message "ERROR: Failed to set KDE wallpaper"
        return 1
    fi
}

# MATE wallpaper setting
set_wallpaper_mate() {
    local wallpaper_path="$1"
    
    if dconf write /org/mate/desktop/background/picture-filename "'$wallpaper_path'" 2>/dev/null; then
        dconf write /org/mate/desktop/background/picture-options "'scaled'" 2>/dev/null || true
        log_message "MATE: Set wallpaper to $wallpaper_path"
        return 0
    else
        log_message "ERROR: Failed to set MATE wallpaper"
        return 1
    fi
}

# Cinnamon wallpaper setting
set_wallpaper_cinnamon() {
    local wallpaper_path="$1"
    
    if dconf write /org/cinnamon/desktop/background/picture-uri "'file://$wallpaper_path'" 2>/dev/null; then
        dconf write /org/cinnamon/desktop/background/picture-options "'scaled'" 2>/dev/null || true
        log_message "Cinnamon: Set wallpaper to $wallpaper_path"
        return 0
    else
        log_message "ERROR: Failed to set Cinnamon wallpaper"
        return 1
    fi
}

# Sway/Wayland wallpaper setting
set_wallpaper_sway() {
    local wallpaper_path="$1"
    
    # Kill existing swaybg processes
    pkill swaybg 2>/dev/null || true
    sleep 0.1
    
    # Start swaybg with the new wallpaper
    if swaybg -i "$wallpaper_path" -m fill > /dev/null 2>&1 & then
        log_message "Sway: Set wallpaper to $wallpaper_path"
        return 0
    else
        log_message "ERROR: Failed to set Sway wallpaper"
        return 1
    fi
}

# Enhanced feh wallpaper setting with multi-monitor support
set_wallpaper_feh() {
    local wallpaper_path="$1"
    local monitors
    mapfile -t monitors < <(get_monitors)
    
    # Try different feh scaling modes for best compatibility
    local feh_modes=("--bg-scale" "--bg-fill" "--bg-center" "--bg-tile")
    local success=false
    
    for mode in "${feh_modes[@]}"; do
        if feh "$mode" "$wallpaper_path" 2>/dev/null; then
            success=true
            break
        fi
    done
    
    if [[ "$success" == true ]]; then
        # Save the feh command to ~/.fehbg for persistence
        {
            echo "#!/bin/sh"
            echo "feh --no-fehbg --bg-scale '$wallpaper_path'"
        } > "$HOME/.fehbg"
        chmod +x "$HOME/.fehbg"
        log_message "feh: Set wallpaper to $wallpaper_path"
        return 0
    else
        log_message "ERROR: Failed to set wallpaper with feh"
        return 1
    fi
}

# Nitrogen wallpaper setting
set_wallpaper_nitrogen() {
    local wallpaper_path="$1"
    
    if nitrogen --set-scaled "$wallpaper_path" --save 2>/dev/null; then
        log_message "nitrogen: Set wallpaper to $wallpaper_path"
        return 0
    else
        log_message "ERROR: Failed to set wallpaper with nitrogen"
        return 1
    fi
}

# hsetroot wallpaper setting
set_wallpaper_hsetroot() {
    local wallpaper_path="$1"
    
    if hsetroot -fill "$wallpaper_path" 2>/dev/null; then
        log_message "hsetroot: Set wallpaper to $wallpaper_path"
        return 0
    else
        log_message "ERROR: Failed to set wallpaper with hsetroot"
        return 1
    fi
}

# Universal wallpaper setting function
set_wallpaper() {
    local wallpaper_path="$1"
    local desktop_env="$2"
    
    # Verify file exists and is readable
    if [[ ! -f "$wallpaper_path" ]] || [[ ! -r "$wallpaper_path" ]]; then
        log_message "ERROR: Cannot read wallpaper file: $wallpaper_path"
        return 1
    fi
    
    case "$desktop_env" in
        "macos")
            set_wallpaper_macos "$wallpaper_path"
            ;;
        "xfce")
            set_wallpaper_xfce "$wallpaper_path"
            ;;
        "gnome"|"unity"|"pantheon"|"budgie")
            set_wallpaper_gnome "$wallpaper_path"
            ;;
        "kde")
            set_wallpaper_kde "$wallpaper_path"
            ;;
        "mate")
            set_wallpaper_mate "$wallpaper_path"
            ;;
        "cinnamon")
            set_wallpaper_cinnamon "$wallpaper_path"
            ;;
        "sway"|"hyprland")
            set_wallpaper_sway "$wallpaper_path"
            ;;
        "openbox"|"i3"|"awesome"|"bspwm"|"dwm"|"lxde"|"qtile"|"xmonad"|"generic_feh")
            set_wallpaper_feh "$wallpaper_path"
            ;;
        "generic_nitrogen")
            set_wallpaper_nitrogen "$wallpaper_path"
            ;;
        "generic_hsetroot")
            set_wallpaper_hsetroot "$wallpaper_path"
            ;;
        *)
            # Intelligent fallback system
            local fallback_methods=("feh" "nitrogen" "hsetroot" "gsettings")
            local success=false
            
            for method in "${fallback_methods[@]}"; do
                case "$method" in
                    "feh")
                        if command -v feh > /dev/null && set_wallpaper_feh "$wallpaper_path"; then
                            success=true && break
                        fi
                        ;;
                    "nitrogen")
                        if command -v nitrogen > /dev/null && set_wallpaper_nitrogen "$wallpaper_path"; then
                            success=true && break
                        fi
                        ;;
                    "hsetroot")
                        if command -v hsetroot > /dev/null && set_wallpaper_hsetroot "$wallpaper_path"; then
                            success=true && break
                        fi
                        ;;
                    "gsettings")
                        if command -v gsettings > /dev/null && set_wallpaper_gnome "$wallpaper_path"; then
                            success=true && break
                        fi
                        ;;
                esac
            done
            
            if [[ "$success" == false ]]; then
                log_message "ERROR: No supported wallpaper setter found for environment: $desktop_env"
                return 1
            fi
            ;;
    esac
}

# Enhanced function to get wallpaper files with better format support
get_wallpaper_list() {
    local wallpaper_dir="$1"
    
    # Comprehensive list of supported image formats
    local formats=("jpg" "jpeg" "png" "bmp" "gif" "tiff" "tif" "webp" "svg" "ico" "ppm" "pgm" "pbm" "xpm" "avif" "heic" "heif")
    local find_args=()
    
    # Build find arguments for case-insensitive matching
    for i in "${!formats[@]}"; do
        if [[ $i -eq 0 ]]; then
            find_args+=("(" "-iname" "*.${formats[$i]}")
        else
            find_args+=("-o" "-iname" "*.${formats[$i]}")
        fi
    done
    find_args+=(")")
    
    # Find wallpapers with size limit to prevent memory issues
    find "$wallpaper_dir" -type f "${find_args[@]}" 2>/dev/null | head -2000
}

# Function to process wallpaper list (shuffle or sort)
process_wallpaper_list() {
    local wallpaper_list="$1"
    
    if [[ "$RANDOM_ORDER" == true ]]; then
        echo "$wallpaper_list" | shuf
    else
        echo "$wallpaper_list" | sort
    fi
}

# Enhanced autostart creation with better desktop file
create_autostart() {
    print_colored "$BLUE" "Setting up autostart for wallpaper slideshow..."
    
    # Create autostart directory if it doesn't exist
    mkdir -p "$(dirname "$DESKTOP_FILE")"
    
    # Create the desktop file with better compatibility
    cat > "$DESKTOP_FILE" << EOF
[Desktop Entry]
Type=Application
Name=Wallpaper Slideshow
Comment=Automatic wallpaper slideshow for all desktop environments
Exec=bash -c 'cd "$(dirname "$SCRIPT_PATH")" && "$SCRIPT_PATH" start'
Icon=preferences-desktop-wallpaper
Hidden=false
NoDisplay=false
X-GNOME-Autostart-enabled=true
X-KDE-autostart-after=panel
X-MATE-Autostart-enabled=true
StartupNotify=false
Terminal=false
Categories=System;Settings;DesktopSettings;
X-Desktop-File-Install-Version=0.26
EOF
    
    chmod +x "$DESKTOP_FILE"
    
    print_colored "$GREEN" "Autostart configured successfully!"
    print_colored "$BLUE" "Desktop file created: $DESKTOP_FILE"
    log_message "Autostart configured for wallpaper slideshow"
}

# Function to remove autostart
remove_autostart() {
    print_colored "$BLUE" "Removing autostart for wallpaper slideshow..."
    
    if [[ -f "$DESKTOP_FILE" ]]; then
        rm "$DESKTOP_FILE"
        print_colored "$GREEN" "Removed desktop file: $DESKTOP_FILE"
    else
        print_colored "$YELLOW" "No autostart desktop file found"
    fi
    
    log_message "Autostart removed for wallpaper slideshow"
}

# Function to check autostart status
check_autostart() {
    if [[ -f "$DESKTOP_FILE" ]]; then
        print_colored "$GREEN" "âœ“ Autostart is enabled"
        echo "  Desktop file: $DESKTOP_FILE"
        return 0
    else
        print_colored "$YELLOW" "âœ— Autostart is not configured"
        return 1
    fi
}

# Main slideshow function with comprehensive error handling
start_slideshow() {
    # Get wallpaper directory from user if not provided
    if [[ -z "${WALLPAPER_DIR:-}" ]]; then
        WALLPAPER_DIR=$(get_wallpaper_directory)
    fi
    
    # Validate wallpaper directory
    if [[ ! -d "$WALLPAPER_DIR" ]]; then
        print_colored "$RED" "Error: Wallpaper directory '$WALLPAPER_DIR' does not exist."
        exit 1
    fi
    
    # Detect desktop environment and OS
    local os_type desktop_env
    os_type=$(detect_os)
    desktop_env=$(detect_desktop_environment)
    
    print_colored "$BLUE" "Detected OS: $os_type"
    print_colored "$BLUE" "Detected desktop environment: $desktop_env"
    
    # Check dependencies and get corrected desktop environment
    if ! desktop_env=$(check_dependencies "$desktop_env"); then
        exit 1
    fi
    
    # Get wallpaper list
    local wallpapers
    wallpapers=$(get_wallpaper_list "$WALLPAPER_DIR")
    
    if [[ -z "$wallpapers" ]]; then
        print_colored "$RED" "Error: No wallpaper files found in '$WALLPAPER_DIR'."
        print_colored "$YELLOW" "Supported formats: JPG, JPEG, PNG, BMP, GIF, TIFF, WebP, SVG, XPM, AVIF, HEIC"
        exit 1
    fi
    
    local wallpaper_count
    wallpaper_count=$(echo "$wallpapers" | wc -l)
    print_colored "$GREEN" "Found $wallpaper_count wallpaper(s) in $WALLPAPER_DIR"
    print_colored "$BLUE" "Slideshow interval: $INTERVAL seconds"
    print_colored "$BLUE" "Random order: $RANDOM_ORDER"
    
    # Save PID for stop functionality
    echo $$ > "$PID_FILE"
    
    log_message "Starting wallpaper slideshow (PID: $$, OS: $os_type, Desktop: $desktop_env, Interval: ${INTERVAL}s, Random: $RANDOM_ORDER)"
    
    # Test wallpaper setting capability with first wallpaper
    local first_wallpaper
    first_wallpaper=$(echo "$wallpapers" | head -n1)
    
    print_colored "$YELLOW" "Testing wallpaper setting capability..."
    if ! set_wallpaper "$first_wallpaper" "$desktop_env"; then
        print_colored "$RED" "Error: Unable to set wallpaper. Please check your desktop environment setup."
        print_colored "$YELLOW" "Check the log file for more details: $LOG_FILE"
        rm -f "$PID_FILE"
        exit 1
    fi
    
    print_colored "$GREEN" "âœ“ Wallpaper slideshow started successfully!"
    print_colored "$BLUE" "Use '$SCRIPT_NAME stop' to stop the slideshow"
    print_colored "$BLUE" "Use '$SCRIPT_NAME status' to check status"
    
    # Main slideshow loop with robust error handling
    local consecutive_errors=0
    local max_consecutive_errors=10
    local last_refresh_time=$(date +%s)
    local refresh_interval=3600  # Refresh wallpaper list every hour
    
    while true; do
        # Refresh wallpaper list periodically
        local current_time=$(date +%s)
        if (( current_time - last_refresh_time > refresh_interval )); then
            print_colored "$BLUE" "Refreshing wallpaper list..."
            wallpapers=$(get_wallpaper_list "$WALLPAPER_DIR")
            if [[ -z "$wallpapers" ]]; then
                log_message "WARNING: No wallpapers found during refresh"
                print_colored "$YELLOW" "Warning: No wallpapers found in directory during refresh"
            else
                local new_count
                new_count=$(echo "$wallpapers" | wc -l)
                print_colored "$GREEN" "Refreshed: Found $new_count wallpaper(s)"
                log_message "Wallpaper list refreshed: $new_count files found"
            fi
            last_refresh_time=$current_time
        fi
        
        # Process wallpaper list (shuffle or sort)
        local processed_wallpapers
        processed_wallpapers=$(process_wallpaper_list "$wallpapers")
        
        # Iterate through wallpapers
        while IFS= read -r wallpaper; do
            [[ -z "$wallpaper" ]] && continue
            
            if [[ -f "$wallpaper" && -r "$wallpaper" ]]; then
                if set_wallpaper "$wallpaper" "$desktop_env"; then
                    print_colored "$GREEN" "Current wallpaper: $(basename "$wallpaper")"
                    consecutive_errors=0  # Reset error counter on success
                else
                    ((consecutive_errors++))
                    print_colored "$RED" "Failed to set wallpaper: $(basename "$wallpaper") (Error $consecutive_errors/$max_consecutive_errors)"
                    log_message "ERROR: Failed to set wallpaper: $wallpaper (consecutive errors: $consecutive_errors)"
                    
                    if (( consecutive_errors >= max_consecutive_errors )); then
                        print_colored "$RED" "Too many consecutive errors ($consecutive_errors). Stopping slideshow."
                        log_message "ERROR: Too many consecutive errors ($consecutive_errors). Stopping slideshow."
                        rm -f "$PID_FILE"
                        exit 1
                    fi
                fi
            else
                log_message "WARNING: Wallpaper file no longer exists or is not readable: $wallpaper"
                print_colored "$YELLOW" "Warning: Skipping inaccessible file: $(basename "$wallpaper")"
            fi
            
            # Sleep for the specified interval
            sleep "$INTERVAL"
        done <<< "$processed_wallpapers"
    done
}

# Enhanced stop function
stop_slideshow() {
    if [[ -f "$PID_FILE" ]]; then
        local pid
        pid=$(cat "$PID_FILE")
        if kill -0 "$pid" 2>/dev/null; then
            if kill "$pid" 2>/dev/null; then
                print_colored "$GREEN" "âœ“ Stopped wallpaper slideshow (PID: $pid)"
                log_message "Slideshow stopped (PID: $pid)"
            else
                print_colored "$RED" "âœ— Failed to stop slideshow process (PID: $pid)"
                return 1
            fi
        else
            print_colored "$YELLOW" "Slideshow process not running (stale PID file)"
        fi
        rm -f "$PID_FILE"
    else
        print_colored "$YELLOW" "No slideshow process found"
        return 1
    fi
}

# Comprehensive status function
status_slideshow() {
    local is_running=false
    
    if [[ -f "$PID_FILE" ]]; then
        local pid
        pid=$(cat "$PID_FILE")
        if kill -0 "$pid" 2>/dev/null; then
            is_running=true
            print_colored "$GREEN" "âœ“ Wallpaper slideshow is running (PID: $pid)"
        else
            print_colored "$YELLOW" "âœ— Slideshow process not running (stale PID file)"
            rm -f "$PID_FILE"
        fi
    else
        print_colored "$YELLOW" "âœ— Wallpaper slideshow is not running"
    fi
    
    # Show system information
    echo ""
    print_colored "$BLUE" "System Information:"
    echo "  OS: $(detect_os)"
    echo "  Desktop Environment: $(detect_desktop_environment)"
    echo "  Script Path: $SCRIPT_PATH"
    
    # Show configuration
    echo ""
    print_colored "$BLUE" "Configuration:"
    echo "  Wallpaper Directory: ${WALLPAPER_DIR:-'Not set'}"
    echo "  Interval: $INTERVAL seconds"
    echo "  Random Order: $RANDOM_ORDER"
    echo "  Log File: $LOG_FILE"
    
    # Show autostart status
    echo ""
    print_colored "$BLUE" "Autostart Status:"
    check_autostart
    
    # Show wallpaper count if directory is set
    if [[ -n "${WALLPAPER_DIR:-}" && -d "$WALLPAPER_DIR" ]]; then
        local wallpaper_count
        wallpaper_count=$(get_wallpaper_list "$WALLPAPER_DIR" | wc -l)
        echo ""
        print_colored "$BLUE" "Wallpaper Information:"
        echo "  Total wallpapers found: $wallpaper_count"
    fi
    
    # Show recent log entries if running
    if [[ "$is_running" == true && -f "$LOG_FILE" ]]; then
        echo ""
        print_colored "$BLUE" "Recent Log Entries:"
        tail -n 5 "$LOG_FILE" | sed 's/^/  /'
    fi
    
    return $([[ "$is_running" == true ]] && echo 0 || echo 1)
}

# Comprehensive usage/help function
show_usage() {
    print_colored "$BLUE" "ðŸ–¼ï¸  Universal Wallpaper Slideshow Script"
    echo ""
    print_colored "$GREEN" "Usage: $0 [command]"
    echo ""
    print_colored "$YELLOW" "Commands:"
    echo "  start              - Start the wallpaper slideshow"
    echo "  stop               - Stop the wallpaper slideshow"
    echo "  restart            - Restart the wallpaper slideshow"
    echo "  status             - Show slideshow status and configuration"
    echo "  enable-autostart   - Enable automatic startup on login"
    echo "  disable-autostart  - Disable automatic startup"
    echo "  help               - Show this help message"
    echo ""
    print_colored "$YELLOW" "Supported Operating Systems:"
    echo "  â€¢ Linux (all distributions)    â€¢ macOS"
    echo "  â€¢ Windows (WSL/Cygwin)         â€¢ BSD variants"
    echo ""
    print_colored "$YELLOW" "Supported Desktop Environments:"
    echo "  â€¢ XFCE          â€¢ GNOME         â€¢ KDE Plasma"
    echo "  â€¢ MATE          â€¢ Cinnamon      â€¢ Unity"
    echo "  â€¢ Pantheon      â€¢ Budgie        â€¢ LXDE/LXQt"
    echo "  â€¢ OpenBox       â€¢ i3            â€¢ Awesome"
    echo "  â€¢ BSPWM         â€¢ DWM           â€¢ Qtile"
    echo "  â€¢ XMonad        â€¢ Sway          â€¢ Hyprland"
    echo "  â€¢ macOS         â€¢ Generic X11   â€¢ Wayland"
    echo ""
    print_colored "$YELLOW" "Configuration (edit script variables):"
    echo "  INTERVAL      - Time between changes (seconds, default: 300)"
    echo "  RANDOM_ORDER  - true for random, false for alphabetical"
    echo ""
    print_colored "$YELLOW" "Supported Image Formats:"
    echo "  JPG, JPEG, PNG, BMP, GIF, TIFF, WebP, SVG, XPM,"
    echo "  AVIF, HEIC, HEIF, PPM, PGM, PBM, ICO"
    echo ""
    print_colored "$YELLOW" "Files Created:"
    echo "  Log File:     $LOG_FILE"
    echo "  PID File:     $PID_FILE"
    echo "  Autostart:    $DESKTOP_FILE"
    echo ""
    print_colored "$BLUE" "Examples:"
    echo "  $0 start                    # Start slideshow (will prompt for directory)"
    echo "  $0 status                   # Check if running"
    echo "  $0 enable-autostart         # Enable autostart"
    echo ""
    print_colored "$GREEN" "For support and updates, visit: https://github.com/wallpaper-slideshow"
}

# Initialize configuration from environment or prompt user
init_config() {
    # If WALLPAPER_DIR is not set, get it from user
    if [[ -z "${WALLPAPER_DIR:-}" ]]; then
        print_colored "$YELLOW" "Wallpaper directory not configured."
        WALLPAPER_DIR=$(get_wallpaper_directory)
        
        # Optionally save to config file for future use
        local config_file="$HOME/.config/wallpaper-slideshow.conf"
        mkdir -p "$(dirname "$config_file")"
        echo "WALLPAPER_DIR=\"$WALLPAPER_DIR\"" > "$config_file"
        print_colored "$GREEN" "Configuration saved to: $config_file"
    fi
}

# Load configuration from config file if it exists
load_config() {
    local config_file="$HOME/.config/wallpaper-slideshow.conf"
    if [[ -f "$config_file" ]]; then
        # Source the config file safely
        while IFS='=' read -r key value; do
            [[ $key =~ ^[[:space:]]*# ]] && continue  # Skip comments
            [[ -z "$key" ]] && continue               # Skip empty lines
            
            # Remove quotes from value
            value=$(echo "$value" | sed 's/^["'\'']*//;s/["'\'']*$//')
            
            case "$key" in
                "WALLPAPER_DIR") WALLPAPER_DIR="$value" ;;
                "INTERVAL") INTERVAL="$value" ;;
                "RANDOM_ORDER") RANDOM_ORDER="$value" ;;
            esac
        done < "$config_file"
    fi
}

# Signal handler for graceful shutdown
cleanup() {
    local exit_code=$?
    print_colored "$YELLOW" "Received shutdown signal. Cleaning up..."
    
    # Remove PID file
    [[ -f "$PID_FILE" ]] && rm -f "$PID_FILE"
    
    log_message "Slideshow stopped by signal (exit code: $exit_code)"
    print_colored "$GREEN" "Wallpaper slideshow stopped."
    exit $exit_code
}

# Set up signal handlers
trap cleanup SIGTERM SIGINT SIGQUIT

# Load existing configuration
load_config

# Main script logic with enhanced command handling
case "${1:-start}" in
    "start")
        # Check if already running
        if [[ -f "$PID_FILE" ]] && kill -0 "$(cat "$PID_FILE")" 2>/dev/null; then
            print_colored "$YELLOW" "Wallpaper slideshow is already running (PID: $(cat "$PID_FILE"))"
            print_colored "$BLUE" "Use '$SCRIPT_NAME stop' to stop it first"
            exit 1
        fi
        
        # Initialize configuration if needed
        init_config
        
        # Start the slideshow
        start_slideshow
        ;;
    "stop")
        stop_slideshow
        ;;
    "restart")
        print_colored "$BLUE" "Restarting wallpaper slideshow..."
        stop_slideshow
        sleep 2
        
        # Initialize configuration if needed
        init_config
        
        start_slideshow
        ;;
    "status")
        status_slideshow
        ;;
    "enable-autostart")
        create_autostart
        ;;
    "disable-autostart")
        remove_autostart
        ;;
    "help"|"-h"|"--help")
        show_usage
        ;;
    *)
        print_colored "$RED" "Invalid command: $1"
        echo ""
        show_usage
        exit 1
        ;;
esac
